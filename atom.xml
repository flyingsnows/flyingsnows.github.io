<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FlyingSnows</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-19T13:26:35.931Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>王志强</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端一些琐碎知识</title>
    <link href="http://yoursite.com/2020/04/19/%E8%AF%A6%E8%A7%A3Spring%E6%A1%86%E6%9E%B6%E7%9A%84AOP%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/04/19/%E8%AF%A6%E8%A7%A3Spring%E6%A1%86%E6%9E%B6%E7%9A%84AOP%E6%9C%BA%E5%88%B6/</id>
    <published>2020-04-19T13:26:35.931Z</published>
    <updated>2020-04-19T13:26:35.931Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="详解Spring框架的AOP机制"><a href="#详解Spring框架的AOP机制" class="headerlink" title="详解Spring框架的AOP机制"></a>详解Spring框架的AOP机制</h1><p>AOP是Spring框架面向切面的编程思想，AOP采用一种称为“横切”的技术，将涉及多业务流程的通用功能抽取并单独封装，形成独立的切面，在合适的时机将这些切面横向切入到业务流程指定的位置中。本篇结合实际案例详细讲述AOP的原理及实现过程。通过本篇的学习，可以达成如下目标。</p><p>● 理解AOP的编程思想及原理</p><p>● 掌握AOP的实现技术</p><p>Spring框架的AOP机制可以让开发者把业务流程中的通用功能抽取出来，单独编写功能代码。在业务流程执行过程中，Spring框架会根据业务流程要求，自动把独立编写的功能代码切入到流程的合适位置。</p><p>例如，在一个业务系统中，用户登录是基础功能，凡是涉及到用户的业务流程都要求用户进行系统登录。如果把用户登录功能代码写入到每个业务流程中，会造成代码冗余，维护也非常麻烦，当需要修改用户登录功能时，就需要修改每个业务流程的用户登录代码，这种处理方式显然是不可取的。比较好的做法是把用户登录功能抽取出来，形成独立的模块，当业务流程需要用户登录时，系统自动把登录功能切入到业务流程中。下图是用户登录功能切入到业务流程示意图。</p><p><img src="/" class="lazyload" data-src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=725733276,316358623&fm=173&app=25&f=JPEG?w=554&h=409&s=0C827C32191F41C814D9E4DA000060B3"  alt="img">图1 用户登录功能切入到业务流程示意图</p><p><strong>1、 一个AOP案例描述</strong></p><p>在课程案例SpringProgram项目中，一个业务流程是校长通过邮件发送上课通知给老师。校长执行该业务时，业务系统并没有对老师进行验证。现在要求校长在发送通知之前，需要对老师进行用户验证。</p><p>具体要求是在尽量不改变原有业务代码的情况下，加入老师验证功能。原有业务代码如下。</p><p><img src="/" class="lazyload" data-src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=795330031,579855669&fm=173&app=25&f=JPEG?w=639&h=294&s=ED86AC1A139B64690CD521DA000090B3"  alt="img"></p><p>EmailNotice业务类代码没有对老师身份进行验证，可以考虑在执行setTeacher方法之前执行验证功能。</p><p>具体的操作步骤是：</p><p>（1）添加老师身份验证功能代码，用于切入到EmailNotice业务类，身份验证功能代码也称为切面，切入点为EmailNotice业务类的setTeacher方法；</p><p>（2）在Spring配置文件中配置AOP，添加切入面、切入点以及需要切入的目标Bean；</p><p>（3）编写测试代码，测试程序运行地正确性。</p><p><strong>2、 实现AOP案例代码</strong></p><p>在实现AOP案例之前，需要确定项目已经引入了Spring框架关于AOP功能的Jar包。下面列出的是spring-aop-5.0版本，其它版本也可以。</p><p>● spring-aop-5.0.8.RELEASE</p><p>● spring-aspects-5.0.8.RELEASE</p><p>另外还需要引入下面的Jar包：</p><p>● aspectjrt</p><p>● aspectjweaver</p><p>在课程案例SpringProgram项目中，相关的Teacher实体类、EmailNotice业务类、Spring配置文件已经存在，为了不影响前面课程的案例。实现AOP的代码重新编写AopTeacher实体类、AopEmailNotice业务类以及Spring配置文件。</p><p><strong>（1）添加AopTeacher实体类</strong></p><p>在课程案例SpringProgram项目中，添加AopTeacher实体类。</p><p><img src="/" class="lazyload" data-src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=849067136,1055929854&fm=173&app=25&f=JPEG?w=639&h=305&s=4896ED1A0B0355644E7504DA0000C0B3"  alt="img"></p><p><strong>（2）添加老师身份验证功能</strong></p><p>在课程案例SpringProgram项目中，添加VerifyUser类，并添加类方法beforeAdvice，该方法需要传入AopTeacher实体类，用于验证老师身份的合法性。</p><p><img src="/" class="lazyload" data-src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=696777882,2520505743&fm=173&app=25&f=JPEG?w=640&h=152&s=EC06AC1ACD62452256F540DB0000D0B3"  alt="img"></p><p><strong>（3）添加AopEmailNotice业务类</strong></p><p>在课程案例SpringProgram项目中，添加AopEmailNotice业务类。</p><p><img src="/" class="lazyload" data-src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=612757776,37610991&fm=173&app=25&f=JPEG?w=639&h=271&s=E986ED1A1311446118F8A5DA000090B3"  alt="img"></p><p>AopEmailNotice业务类内置了AopTeacher对象，并通过sendMessage方法发送通知给AopTeacher对象。setTeacher方法用于设置AopTeacher对象，在设置之前需要验证AopTeacher对象身份的合法性，也就是要在setTeacher方法执行之前，执行VerifyUser类的beforeAdvice方法。</p><p><strong>（4）添加Spring配置文件</strong></p><p>在课程案例SpringProgram项目中，添加Spring配置文件aop.xml。</p><p><img src="/" class="lazyload" data-src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=4167865331,1223142298&fm=173&app=25&f=JPEG?w=640&h=405&s=ACE6AD1A09BFF0CE5AF511DB000080B1"  alt="img"></p><p>aop.xml需要使用AOP命名空间，因此需要在配置文件中导入spring-aop架构，添加下面的AOP命名空间。</p><p><img src="/" class="lazyload" data-src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=3352201336,578430190&fm=173&app=25&f=JPEG?w=640&h=82"  alt="img"></p><p>标签用于AOP创建代理切入类（代理类）是基于接口的还是基于类的，如果proxy-target-class 属性值被设置为true，那么创建基于类的代理，否则创建基于接口的代理。</p><p>标签用于配置AOP。其中子标签添加一个切面Aspect，一个切面可以是一个模块或一个类。例如验证用户身份的VerifyUser类，该切面将被AOP调用。可以配值多个切面。</p><p>标签用于声明一个切入点,也就是切面提供的哪些方法可以被调用。expression 为切入点的表达式，用于定义切入点的路径。</p><p>例如：</p><p>execution(*　com.milihua.springprogram.notice.AopEmailNotice.setTeacher(..))</p><p>上述表达式的意思是切入点为AopEmailNotice的setTeacher方法。其中＊号表示切入点为任意的返回类型，（．．）表示任意参数。</p><p>再如：</p><p>execution(* com.milihua.springprogram.notice. .<em>.</em>(..))</p><p>上述表达式的意思是切入点为com.milihua.springprogram.notice包及子包下所有的类及类中所有的方法。</p><p>又如：</p><p>execution(* com.milihua.springprogram.notice. <em>.</em>(..))</p><p>上述表达式的意思是切入点为com.milihua.springprogram.notice包下所有的类及类中所有的方法。</p><p><strong>（5）编写测试代码</strong></p><p>在课程案例SpringProgram项目中，添加AopTest测试类。</p><p><img src="/" class="lazyload" data-src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=3829869560,3660644117&fm=173&app=25&f=JPEG?w=640&h=176&s=EDC2FD1ADF704803486480DB0000C0B3"  alt="img"></p><p>测试程序运行结果如下图所示。</p><p><img src="/" class="lazyload" data-src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2794633071,3334315994&fm=173&app=25&f=JPEG?w=554&h=159&s=4650ED3A83F8582142D069DE02009032"  alt="img"></p><p><strong>3、AOP编程思想及术语</strong></p><p>AOP是面向切面的编程，其编程思想是把散布于不同业务但功能相同的代码从业务逻辑中抽取出来，封装成独立的模块，这些独立的模块被称为切面，切面的具体功能方法被称为关注点。在业务逻辑执行过程中，AOP会把分离出来的切面和关注点动态切入到业务流程中，这样做的好处是提高了功能代码的重用性和可维护性。</p><p>例如，前面案例的VerifyUser类就是切面，VerifyUser类的beforeAdvice就是关注点。VerifyUser切面的功能就是验证老师身份，可以应用到与老师相关的不同业务流程中。AopEmailNotice是一个业务类，负责发送通知给老师，在发送通知之前需要验证老师的身份。AOP会在AopEmailNotice类的setTeacher方法执行之前，将beforeAdvice关注点切入到AopEmailNotice业务类中，并执行beforeAdvice方法。</p><p>Spring框架提供了@AspectJ 注解方法和基于XML架构的方法来实现AOP。前面的案例是基于XML架构的方法，后面一节会讲述基于@AspectJ 注解的方法。下面结合前面的案例讲述一下AOP的相关术语。</p><p>● Aspect</p><p>表示切面。切入业务流程的一个独立模块。例如，前面案例的VerifyUser类，一个应用程序可以拥有任意数量的切面。</p><p>● Join point</p><p>表示连接点。也就是业务流程在运行过程中需要插入切面的具体位置。例如，前面案例的AopEmailNotice类的setTeacher方法就是一个连接点。</p><p>● Advice</p><p>表示通知。是切面的具体实现方法。可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）和环绕通知（Around）五种。实现方法具体属于哪类通知，是在配置文件和注解中指定的。例如，VerifyUser类的beforeAdvice方法就是前置通知。</p><p>● Pointcut</p><p>表示切入点。用于定义通知应该切入到哪些连接点上，不同的通知通常需要切入到不同的连接点上。例如，前面案例配置文件的<a href="aop:pointcut">aop:pointcut</a>标签。</p><p>● Target</p><p>表示目标对象。被一个或者多个切面所通知的对象。例如，前面案例的AopEmailNotice类。</p><p>● Proxy</p><p>表示代理对象。将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象为目标对象的业务逻辑功能加上被切入的切面所形成的对象。</p><p>● Weaving</p><p>表示切入，也称为织入。将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译期、类装载期及运行期。</p><p><strong>课程小结</strong></p><p>（1）本篇探讨了AOP的编程思想，其主要思想是让开发者把诸多业务流程中的通用功能抽取出来，单独编写功能代码，形成独立的模块，这些模块也被称为切面。在业务流程执行过程中，Spring框架会根据业务流程要求，自动把切面切入到流程的合适位置。</p><p>（2）本篇也通过案例讲述了AOP的实现过程，具体实现步骤是：首先编写需要切入业务流程的独立模块（也称为切面）和切入点（模块中的方法）；然后在Spring配置文件中配置AOP，添加切入面、切入点以及需要切入的目标Bean；最后编写测试代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="AOP" scheme="http://yoursite.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>前端一些琐碎知识</title>
    <link href="http://yoursite.com/2020/04/19/%E5%89%8D%E7%AB%AF%E4%B8%80%E4%BA%9B%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2020/04/19/%E5%89%8D%E7%AB%AF%E4%B8%80%E4%BA%9B%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86/</id>
    <published>2020-04-19T13:26:35.770Z</published>
    <updated>2020-04-19T13:26:35.770Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="前端一些琐碎知识"><a href="#前端一些琐碎知识" class="headerlink" title="前端一些琐碎知识"></a>前端一些琐碎知识</h1><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><p>jQuery是一个库，js的大量函数（方法）</p><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200314171845060.png"  alt="image-20200314171845060"></p><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200314172131549.png"  alt="image-20200314172131549"></p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>通过拦截器实现方法耗时统计与警告</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package com.xy.interceptors;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line">import org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 方法耗时统计拦截器</span><br><span class="line">*&#x2F;</span><br><span class="line">public class MethodTimerInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER&#x3D;Logger.getLogger(MethodTimerInterceptor.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;前置功能，  开始到结束，两个点减法</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;定义开始时间</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">        &#x2F;&#x2F;2.将其存到请求域当中</span><br><span class="line">        request.setAttribute(&quot;start&quot;,start);</span><br><span class="line">        &#x2F;&#x2F;记录请求日志</span><br><span class="line">        LOGGER.info(request.getRequestURI()+&quot;,请求到达&quot;);</span><br><span class="line">        &#x2F;&#x2F;3,返回true，才会找下一个拦截器，如果没有下一个拦截器，则去Controller</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;1,取出start</span><br><span class="line">        long start &#x3D; (long) request.getAttribute(&quot;start&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2,得到end</span><br><span class="line">        long end &#x3D;System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;3,记录耗时</span><br><span class="line">        long spendTime &#x3D; end-start;</span><br><span class="line">        if (spendTime&gt;2000)&#123;</span><br><span class="line">            LOGGER.warn(&quot;方法耗时严重，请及时处理，耗时：&quot;+spendTime);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            LOGGER.info(&quot;方法耗时&quot;+spendTime+&quot;毫秒，正常&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>springmvc的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--拦截器的配置--&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&#x2F;*&quot;&#x2F;&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;com.xy.interceptors.MethodTimerInterceptor&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;&#x2F;mvc:interceptor&gt;</span><br><span class="line">&lt;&#x2F;mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Html" scheme="http://yoursite.com/categories/Html/"/>
    
    
      <category term="Html ajax" scheme="http://yoursite.com/tags/Html-ajax/"/>
    
  </entry>
  
  <entry>
    <title>常用注解</title>
    <link href="http://yoursite.com/2020/04/19/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/04/19/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-04-19T13:26:35.724Z</published>
    <updated>2020-04-19T13:26:35.724Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><h2 id="ResponseBody详解"><a href="#ResponseBody详解" class="headerlink" title="@ResponseBody详解"></a>@ResponseBody详解</h2><p>@ResponseBody的作用其实是将java对象转为json格式的数据。</p><p>@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。<br>注意：在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。<br>@ResponseBody是作用在方法上的，@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】。<br>注意：在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。@RequestBody 将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。</p><p>后台 Controller类中对应的方法：<br>@RequestMapping(“/login.do”)<br>@ResponseBody<br>public Object login(String name, String password, HttpSession session) {<br>    user = userService.checkLogin(name, password);<br>    session.setAttribute(“user”, user);<br>    return new JsonResult(user);<br>}</p><p>@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml格式 或者 json等】封装为对应的 JavaBean 对象，<br>封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上。<br>如上面的登录后台代码可以改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;login.do&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Object login(@RequestBody User loginUuser, HttpSession session) &#123;</span><br><span class="line">user &#x3D; userService.checkLogin(loginUser);</span><br><span class="line">session.setAttribute(&quot;user&quot;, user);</span><br><span class="line">return new JsonResult(user);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><p>@RequestBody 注解则是将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。<br>作用：</p><p>1) 该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定<br>    到要返回的对象上；<br>2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。<br>使用时机：</p><p>A) GET、POST方式提时， 根据request header Content-Type的值来判断:</p><pre><code>application/x-www-form-urlencoded， 可选（即非必须，因为这种情况的数据@RequestParam, @ModelAttribute</code></pre><p>也可以处理，当然@RequestBody也能处理）；<br>    multipart/form-data, 不能处理（即使用@RequestBody不能处理这种格式的数据）；<br>    其他格式， 必须（其他格式包括application/json, application/xml等。这些格式的数据，必须使用@RequestBody来处理）；<br>B) PUT方式提交时， 根据request header Content-Type的值来判断:</p><p>application/x-www-form-urlencoded， 必须；multipart/form-data, 不能处理；其他格式， 必须；<br>说明：request的body部分的数据编码格式由header部分的Content-Type指定；</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value &#x3D; &quot;user&#x2F;login&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">&#x2F;&#x2F; 将ajax（datas）发出的请求写入 User 对象中</span><br><span class="line">public User login(@RequestBody User user) &#123;   </span><br><span class="line">&#x2F;&#x2F; 这样就不会再被解析为跳转路径，而是直接将user对象写入 HTTP 响应正文中</span><br><span class="line">    return user;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Configuation"><a href="#Configuation" class="headerlink" title="@Configuation"></a>@Configuation</h2><p>@Configuation等价于<Beans></Beans></p><h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p> @Bean等价于<Bean></Bean></p><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p> @ComponentScan等价于&lt;context:component-scan base-package=”com.dxz.demo”/&gt;</p><p> @Bean放到方法上，意思是这个方法产生一个bean并交给spring容器管理，这样等用的时候，使用@Autowired ,   @Resource等注解能够实现自动注入如果注解没有指定生成的bean的名称则默认名称为方法名，如果指定则按照指定名称。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注解指定<span class="selector-tag">bean</span>名称示例：<span class="keyword">@Bean</span>(name="aaa")</span><br></pre></td></tr></table></figure><h2 id="Component注解的用法"><a href="#Component注解的用法" class="headerlink" title="@Component注解的用法"></a>@Component注解的用法</h2><p><code>@Component</code>（和<code>@Service</code>和<code>@Repository</code>）用于自动检测和使用类路径扫描自动配置bean。注释类和bean之间存在隐式的一对一映射（即每个类一个bean）。这种方法对需要进行逻辑处理的控制非常有限，因为它纯粹是声明性的。</p><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p>@ConfigurationProperties可以将外部配置文件（比如applicaition.properties）加载进来，填充对象的对应字段的数据，然后供其他Bean使用。<br>整个项目结构是这样的：</p><p>这里我写了一个外部配置文件(application.yml)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  production:</span><br><span class="line">    url: http:&#x2F;&#x2F;production.example.com</span><br><span class="line">    name: production mode</span><br><span class="line">  dev:</span><br><span class="line">    url: http:&#x2F;&#x2F;dev.example.com</span><br><span class="line">    name: developer mode</span><br></pre></td></tr></table></figure><p>可以看见配置文件的数据有结构化特点，即可以生成一个相应的对象。<br>应该是这个样子：</p><p>可以看见配置文件的数据有结构化特点，即可以生成一个相应的对象。<br>应该是这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Environment&#123;</span><br><span class="line">     Production production;</span><br><span class="line">     Dev dev;</span><br><span class="line">     class Production&#123;</span><br><span class="line">           String url;</span><br><span class="line">           String name;</span><br><span class="line">     &#125;</span><br><span class="line">     class Dev&#123;</span><br><span class="line">           String url;</span><br><span class="line">           String name;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实的代码是这个样子：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20190103210628436.png"  alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Configuration   &#x2F;&#x2F;配置类注解，被自动扫描发现</span><br><span class="line">@PropertySource(&quot;classpath:application.yml&quot;) &#x2F;&#x2F;指明配置源文件位置</span><br><span class="line">@ConfigurationProperties(&quot;environment&quot;) &#x2F;&#x2F;指明前缀</span><br><span class="line">public class EnvConfig &#123;</span><br><span class="line">    private final Dev dev&#x3D;new Dev();</span><br><span class="line">    private final Production production&#x3D;new Production();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Dev getDev() &#123;</span><br><span class="line">        return dev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;getXXX必须中xxx和字段名production严格一致，否则出异常，即使松弛绑定，也要这样</span><br><span class="line">    public Production getProduction() &#123;</span><br><span class="line">        return production;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class Dev&#123;</span><br><span class="line">        private String url;</span><br><span class="line">        private String name;</span><br><span class="line">    </span><br><span class="line">        public String getUrl() &#123;</span><br><span class="line">            return url;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public void setUrl(String url) &#123;</span><br><span class="line">            this.url &#x3D; url;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;toString</span><br><span class="line">    &#125;</span><br><span class="line">    public static class Production&#123;</span><br><span class="line">        private String url;</span><br><span class="line">        private String name;</span><br><span class="line">        &#x2F;&#x2F;setter and getter省略</span><br><span class="line">       &#x2F;&#x2F;toString</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;toString()</span><br></pre></td></tr></table></figure><p>下面测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestStaticController &#123;</span><br><span class="line">    Logger log&#x3D; LoggerFactory.getLogger(TestStaticController.class);</span><br><span class="line">    @Autowired</span><br><span class="line">    public EnvConfig env;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;envtest&quot;)</span><br><span class="line">    public String getEnv()&#123;</span><br><span class="line">        log.info(this.env.toString());</span><br><span class="line">        return &quot;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过发送HTTP请求，将会在日志中看到：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20190103210834303.png"  alt="img"></p><p>可以看见，外部配置文件填充了对象EnvConfig，并可以被容器自动注入到其他对象中。另外，外部配置文件映射成对象还有其他技术如：映射成数组，Map…</p><h3 id="Springboot项目中-如何获取-Configuration注解标注的配置类"><a href="#Springboot项目中-如何获取-Configuration注解标注的配置类" class="headerlink" title="Springboot项目中 如何获取@Configuration注解标注的配置类"></a>Springboot项目中 如何获取@Configuration注解标注的配置类</h3><blockquote><ul><li><p>整个springboot并没有在spring的基础上提供什么额外的功能。</p><p>从开发人员的角度来看，springBoot的最大作用就是引入某些jar包后，自动为spring上下文环境生成某些特定功能的Bean，这样就可以自动提供某些相关功能。</p></li><li><p>从实现的角度来看，spring通过被标记了@Configuration的类提供一些提前生成好的Bean提供特别的功能，而用@Contional系列的注解限制生成的条件，通常就是@ConditionalOnClass和@ConditionalOnMissingBean注解的配合使用。前者确定某些功能需要的class已经有了，后者确定你没有自己生成相关的bean，才提供默认的。</p></li><li><p>可以使用@AutoConfigureBefore，@AutoConfigureAfter，@AutoconfigureOrder 来确定某个自动注册类的生效顺序。作用类比@Order。</p></li><li><p>自动注册一般提供2个module：一个是autoconfigure jar包，一个是starter jar包。其中starter这种jar里面并没有代码，是空的。唯一的作用是将需要的各种jar写入构建文件，这样引入此starter，就不要再去关心相应的其他jar了。</p><p>springboot自己的starter实现是这么干的。</p><p>SpringCloudNetflixZuul是将这两者统一于一个module中来实现的</p></li></ul></blockquote><p>主要分成以下三个场景：</p><ol><li><p>@Configuration配置类在程序可以扫描到的package里，也就是@ComponentScan注解所指定的package里。SpringBoot工程天然支持该类配置类注入方式。</p><p><strong>最佳实践：</strong></p><p><img src="/" class="lazyload" data-src="https:////upload-images.jianshu.io/upload_images/7091173-35a91187d67cabd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/428/format/webp"  alt="img"></p><p>最佳实践</p></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@SpringBootApplication注解中含有@ComponentScan</span></span><br><span class="line"><span class="number">1</span> <span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="number">4</span>         SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line"><span class="number">5</span>     &#125;</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>@Configuration配置类没有在package扫描路径下，即不是项目开发人员自己编写的代码。</p><p>比如制作第三方包供他人在springboot项目中使用，如RPC框架、starter工程、spring-cloud-netflix-zuul等。</p><p><strong>最佳实践：</strong></p><blockquote><p>1、编写AutoConfiguration配置类</p><p>2、在META-INF/spring.factories里用org.springframework.boot.autoconfigure.EnableAutoConfiguration来指定。</p><p>spring-boot-autoconfigure包里的配置类都是通过这种方式引入的。</p></blockquote><p><strong>示例：</strong></p><p>用于在项目中导入的第三方包<strong>spring-cloud-netflix-zuul</strong></p><p><img src="/" class="lazyload" data-src="https:////upload-images.jianshu.io/upload_images/7091173-b828a7b5c68cf121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/498/format/webp"  alt="img"></p><p>image</p><p><img src="/" class="lazyload" data-src="https:////upload-images.jianshu.io/upload_images/7091173-b70253eeeaab2af1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/654/format/webp"  alt="img"></p><p>image</p><p>引入spring-cloud-netflix-zuul的demo项目(实际是通过spring-cloud-starter-zuul引入的)</p><p>当然，这个方式需要程序使用@EnableAutoConfiguration注解，这个注解是通过AutoConfigurationImportSelector来扫描spring.factories文件，把定义的配置类引入的。</p></li></ol><blockquote><p><strong>读取spring.factories文件的实现</strong><br> 是通过org.springframework.core.io.support.SpringFactoriesLoader实现的。<br> SpringFactoriesLoader的实现类似于SPI（Service Provider Interface）</p><p>java SPI提供一种服务发现机制，为某个接口寻找服务实现的机制。</p><p>有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。<br> ​</p></blockquote><p>实现说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="number">4</span>         SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line"><span class="number">5</span>     &#125;</span><br><span class="line"><span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure><p>这是springboot项目中应用最常见的启动方式，核心有两个：</p><ul><li>@SpringBootApplication注解</li><li>SpringApplication.run()静态方法</li></ul><p>和我们此处讨论有关系的是注解<strong>@SpringBootApplication</strong></p><p>@SpringBootApplication源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">     <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">     @<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;....&#125;</span><br></pre></td></tr></table></figure><p>@ComponentScan，spring的自动扫描注解，对应方法一。</p><p>@EnableAutoConfiguration：借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器（建议放在根包路径下，这样可以扫描子包和类）</p><p>@EnableAutoConfiguration源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;....&#125;</span><br></pre></td></tr></table></figure><p>其核心是一个EnableAutoConfigurationImportSelector类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableAutoConfigurationImportSelector</span></span></span><br><span class="line"><span class="class">     <span class="keyword">extends</span> <span class="title">AutoConfigurationImportSelector</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>核心方法在顶级接口ImportSelector的<strong>selectImports()</strong>的实现上，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//1.从META-INF/spring-autoconfigure-metadata.properties文件中载入配置属性（有一些有默认值）</span></span><br><span class="line">        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">                .loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">         <span class="comment">//2.获取注解属性</span></span><br><span class="line">        AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">     <span class="comment">//3.获取自动配置类    </span></span><br><span class="line">         List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">                attributes);</span><br><span class="line">         <span class="comment">//4.移除重复的</span></span><br><span class="line">        configurations = removeDuplicates(configurations);</span><br><span class="line">         <span class="comment">//5.排序</span></span><br><span class="line">        configurations = sort(configurations, autoConfigurationMetadata);</span><br><span class="line">         <span class="comment">//6.排出需要排出的</span></span><br><span class="line">        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">        checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">         <span class="comment">//6.过滤器OnClassCondition（注解中配置存在某类才生效）</span></span><br><span class="line">        configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">         <span class="comment">//7.触发自动配置导入监听事件</span></span><br><span class="line">        fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> configurations.toArray(<span class="keyword">new</span> String[configurations.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>使用@Import注解</p><p>这个注解可以引入三种类</p><ul><li><p>使用了@Configuration注解的类</p><blockquote><p>如spring-cloud-netflix中ZuulProxyAutoConfiguration通过@import导入了若干个被@Configuration注解的类</p></blockquote><p><img src="/" class="lazyload" data-src="https:////upload-images.jianshu.io/upload_images/7091173-b0c39f1bbca807e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/750/format/webp"  alt="img"></p><p>image</p></li><li><p>ImportSelector的子类(严格说来这不属于被@Configuration标注的配置类这一前提，但也属于springboot自动配置能力的一种，故罗列在此)</p><blockquote><p>如@EnableAutoConfiguration中所引入的EnableAutoConfigurationImportSelector</p></blockquote><p><img src="/" class="lazyload" data-src="https:////upload-images.jianshu.io/upload_images/7091173-cd6e94c2ede91444.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/806/format/webp"  alt="img"></p><p>image</p></li><li><p>ImportBeanDefinitionRegistrar的子类</p><p>{todo}</p></li></ul></li></ol><h2 id="Condition"><a href="#Condition" class="headerlink" title="@Condition"></a>@Condition</h2><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200322114827645.png"  alt="image-20200322114827645"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring SpringBoot 注解" scheme="http://yoursite.com/tags/Spring-SpringBoot-%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>前端一些琐碎知识</title>
    <link href="http://yoursite.com/2020/04/19/VUE/"/>
    <id>http://yoursite.com/2020/04/19/VUE/</id>
    <published>2020-04-19T13:26:35.604Z</published>
    <updated>2020-04-19T13:26:35.604Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>前端一些琐碎知识</title>
    <link href="http://yoursite.com/2020/04/19/SpringSecurity/"/>
    <id>http://yoursite.com/2020/04/19/SpringSecurity/</id>
    <published>2020-04-19T13:26:35.555Z</published>
    <updated>2020-04-19T13:26:35.555Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><p>Spring Security是Spring提供的一个安全框架，提供认证和授权功能，最主要的是它提供了简单的使用方式，同时又有很高的灵活性，简单，灵活，强大。</p><p>SecurityContextHolder，SecurityContext，Authentication是Spring Security的基础对象。</p><ul><li>SecurityContextHolder：存储当前的SecurityContext，即认证用户的上下文信息，内部使用ThreadLocal。</li><li>SecurityContext：持有Authentication对象和其他可能需要的信息</li><li>UserDetails：从Authentication中获取的对象，代表当前用户的具体信息</li><li>UserDetailsService：获取UserDetails的逻辑，一般封装了查询用户的逻辑，内部只有一个方法：</li><li>UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;</li><li>GrantedAuthority：当前用户获取到的授权信息。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="SpringSecurity" scheme="http://yoursite.com/categories/SpringSecurity/"/>
    
    
      <category term="SpringSecurity" scheme="http://yoursite.com/tags/SpringSecurity/"/>
    
  </entry>
  
  <entry>
    <title>前端一些琐碎知识</title>
    <link href="http://yoursite.com/2020/04/19/spring-boot/"/>
    <id>http://yoursite.com/2020/04/19/spring-boot/</id>
    <published>2020-04-19T13:26:35.439Z</published>
    <updated>2020-04-19T13:26:35.439Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="原理初探"><a href="#原理初探" class="headerlink" title="原理初探"></a>原理初探</h1><h2 id="自动装配："><a href="#自动装配：" class="headerlink" title="自动装配："></a>自动装配：</h2><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><ul><li>spring-boot-dependencies:核心依赖在父工程</li><li>我们在写或者引入一些Springboot依赖的时候，不需要指定版本，就因为有这些版本仓库</li></ul><h3 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>启动器：说白了就是springboot的启动场景；</li><li>比如spring-boot-starter-web ,他就会帮我们自动导入web环境所有的依赖！</li><li>springboot会将所有的场景，都变成一个个的启动器starter</li></ul><h3 id="主程序："><a href="#主程序：" class="headerlink" title="主程序："></a>主程序：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注解:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootConfiguration：springboot的配置</span><br><span class="line">@Configuration：spring配置类</span><br><span class="line">@Component：说明这也是spring的一个组件</span><br><span class="line">@EnableAutoConfiguration自动配置</span><br><span class="line">@AutoConfigurationPackage ：自动配置包</span><br><span class="line">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br></pre></td></tr></table></figure><h1 id="SpringBoot-Web开发"><a href="#SpringBoot-Web开发" class="headerlink" title="SpringBoot Web开发"></a>SpringBoot Web开发</h1><h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">                CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">                <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;<span class="string">"/webjars/**"</span>&#125;).addResourceLocations(<span class="keyword">new</span> String[]&#123;<span class="string">"classpath:/META-INF/resources/webjars/"</span>&#125;).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">                <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;staticPathPattern&#125;).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations())).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><p>在springboot，我们可以使用以下方式处理静态资源</p><ul><li>webjars        localhost:8080/webjars/下的根目录</li><li>public，static，/**，resources      localhost:8080/</li></ul></li><li><p>优先级：resources&gt;static&gt;public</p></li></ul><h2 id="首页如何定制"><a href="#首页如何定制" class="headerlink" title="首页如何定制"></a>首页如何定制</h2><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.thymeleaf&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;thymeleaf-spring5&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.thymeleaf.extras&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;thymeleaf-extras-java8time&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="扩展和全面接管SpringMVC"><a href="#扩展和全面接管SpringMVC" class="headerlink" title="扩展和全面接管SpringMVC"></a>扩展和全面接管SpringMVC</h2><p>在spring boot中 MVC这部分也有默认自动配置，也就是说我们不用做任何配置，那么也是OK的，这个配置类就是 WebMvcAutoConfiguration，但是也时候我们想设置自己的springMvc配置怎么办呢 。</p><p>我们也可以写个自己的配置类，继承 WebMvcConfigurer 重写需要的配置方法 。在spring boot 早期是继承WebMvcConfigurerAdapter ，但是高版已标上注解@Deprecated，注意：在配置类中不要标注：@EnableWebMvc，否则，spring boot的配置全部失效，只留自己扩展配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public&#96; &#96;class&#96; &#96;MyMvcConfig Implements WebMvcConfigurer &#123; </span><br><span class="line"> @Override</span><br><span class="line"> public&#96; &#96;void&#96; &#96;addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line"> &#x2F;&#x2F; super.addViewControllers(registry);</span><br><span class="line"> &#x2F;&#x2F;浏览器发送 &#x2F;success请求来到 success</span><br><span class="line"> registry.addViewController(&#96;&#96;&quot;&#x2F;success&quot;&#96;&#96;).setViewName(&#96;&#96;&quot;success&quot;&#96;&#96;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码浅析：</strong></p><p>1.首先我们来看看WebMvcAutoConfiguration这个配置类，这个配置了有首页的默认路劲，还有一些静态资源路劲，而这些方法在它的一个内部类中，如下代码（删除了部分代码）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration(</span><br><span class="line">        proxyBeanMethods &#x3D; false</span><br><span class="line">    )</span><br><span class="line">    @Import(&#123;WebMvcAutoConfiguration.EnableWebMvcConfiguration.class&#125;)</span><br><span class="line">    @EnableConfigurationProperties(&#123;WebMvcProperties.class, ResourceProperties.class&#125;)</span><br><span class="line">    @Order(0)</span><br><span class="line">    public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，内部类 WebMvcAutoConfigurationAdapter 标记 @Configuration，并导入另一个内部类 @Import({WebMvcAutoConfiguration.EnableWebMvcConfiguration.class})，我们看下这个类，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点在它的父类， DelegatingWebMvcConfiguration 代码如下 （写了几个案列方法，其他代码省略。）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configurers.addResourceHandlers(registry);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>来看看 WebMvcConfigurerComposite 的 addResourceHandlers的方法做了什么 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">    Iterator var2 &#x3D; this.delegates.iterator();</span><br><span class="line"></span><br><span class="line">    while(var2.hasNext()) &#123;</span><br><span class="line">        WebMvcConfigurer delegate &#x3D; (WebMvcConfigurer)var2.next();</span><br><span class="line">        delegate.addViewControllers(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里我们知道，不管是spring boot中实现的 WebMvcConfigurer 类，还是我们自己实现 WebMvcConfigurer ，只要我们把实现类注入到容器中，就会被 注入 WebMvcConfigurerComposite 这个类成员变量 delegates中。</p><p>而 WebMvcConfigurerComposite 有是实现了 WebMvcConfigurer 。当调用 WebMvcConfigurer中 xxx方法的，就会遍历 delegates 中所有 WebMvcConfigurer 的方法xxx 。那我们的扩展配置MyMvcConfig 也就被调用了。</p><p>If you want to keep those Spring Boot MVC customizations and make more <a href="https://docs.spring.io/spring/docs/5.2.4.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">MVC customizations</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurer</code> but <strong>without</strong> <code>@EnableWebMvc</code>.</p><p>If you want to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code>, or <code>ExceptionHandlerExceptionResolver</code>, and still keep the Spring Boot MVC customizations, you can declare a bean of type <code>WebMvcRegistrations</code> and use it to provide custom instances of those components.</p><p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>, or alternatively add your own <code>@Configuration</code>-annotated <code>DelegatingWebMvcConfiguration</code> as described in the Javadoc of <code>@EnableWebMvc</code>.</p><p>在springboot中，有非常多的xxxConfiguration 帮助我们进行扩展配置，只要看见了这个东西，我们就要注意了！</p><h2 id="页面国际化"><a href="#页面国际化" class="headerlink" title="页面国际化"></a>页面国际化</h2><ul><li>我们需要配置i18n文件</li><li>wom我们如果在项目中进行按钮自动切换，我们需要自定义一个组件LocaleResolver</li><li>记得将自己写的组件配置到Spring容器@Bean</li><li>#{}</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>前端一些琐碎知识</title>
    <link href="http://yoursite.com/2020/04/19/Maven%E8%A7%A3%E5%86%B3%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%BF%87%E6%BB%A4%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/04/19/Maven%E8%A7%A3%E5%86%B3%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%BF%87%E6%BB%A4%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-19T13:26:35.392Z</published>
    <updated>2020-04-19T13:26:35.392Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Maven解决静态资源过滤问题"><a href="#Maven解决静态资源过滤问题" class="headerlink" title="Maven解决静态资源过滤问题"></a>Maven解决静态资源过滤问题</h1><h2 id="一、认识静态资源与动态资源"><a href="#一、认识静态资源与动态资源" class="headerlink" title="一、认识静态资源与动态资源"></a>一、认识静态资源与动态资源</h2><ul><li>静态资源，包含HTMl,图片,CSS,JS等不需要与数据库交互的一类文件</li><li>动态资源：需要与数据库交互，可以根据需要显示不同的数据，不需要修改页面</li></ul><h2 id="二、解决Maven中静态资源过滤"><a href="#二、解决Maven中静态资源过滤" class="headerlink" title="二、解决Maven中静态资源过滤"></a>二、解决Maven中静态资源过滤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">            &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">            &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">        &lt;&#x2F;includes&gt;</span><br><span class="line">        &lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span><br><span class="line">    &lt;&#x2F;resource&gt;</span><br><span class="line">    &lt;resource&gt;</span><br><span class="line">        &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">            &lt;include&gt;**&#x2F;*.properties&lt;&#x2F;include&gt;</span><br><span class="line">            &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">        &lt;&#x2F;includes&gt;</span><br><span class="line">        &lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span><br><span class="line">    &lt;&#x2F;resource&gt;</span><br><span class="line">&lt;&#x2F;resources&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><h2 id="三、ssm整合常用依赖"><a href="#三、ssm整合常用依赖" class="headerlink" title="三、ssm整合常用依赖"></a>三、ssm整合常用依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.47&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.mchange&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.9.5.2&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;servlet-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.5&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;javax.servlet.jsp&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jsp-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.2&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.5.2&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.0.2&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="四、mybatis配置"><a href="#四、mybatis配置" class="headerlink" title="四、mybatis配置"></a>四、mybatis配置</h2><ul><li><h3 id="通过configuration配置"><a href="#通过configuration配置" class="headerlink" title="通过configuration配置"></a>通过configuration配置</h3></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">  PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">  &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;environments default&#x3D;&quot;development&quot;&gt;</span><br><span class="line">    &lt;environment id&#x3D;&quot;development&quot;&gt;</span><br><span class="line">      &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;</span><br><span class="line">      &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;dataSource&gt;</span><br><span class="line">    &lt;&#x2F;environment&gt;</span><br><span class="line">  &lt;&#x2F;environments&gt;</span><br><span class="line">  &lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource&#x3D;&quot;org&#x2F;mybatis&#x2F;example&#x2F;BlogMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><ul><li><h3 id="通过Spring配置"><a href="#通过Spring配置" class="headerlink" title="通过Spring配置"></a>通过Spring配置</h3></li></ul><p>配置文件database.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line"># 如果使用mysql8.0 增加一个时区配置</span><br><span class="line">jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ssmbuild?useSSL&#x3D;true&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">jdbc.username&#x3D;root</span><br><span class="line">jdbc.password&#x3D;root</span><br></pre></td></tr></table></figure><p>通过spring-dao关联数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line">&lt;!--    1.关联数据库配置文件--&gt;</span><br><span class="line">    &lt;context:property-placeholder location&#x3D;&quot;classpath:database.properties&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><h2 id="五、ApplicationContext-xml配置"><a href="#五、ApplicationContext-xml配置" class="headerlink" title="五、ApplicationContext.xml配置"></a>五、ApplicationContext.xml配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;...&quot; class&#x3D;&quot;...&quot;&gt;  </span><br><span class="line">        &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;...&quot; class&#x3D;&quot;...&quot;&gt;</span><br><span class="line">        &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- more bean definitions go here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><h2 id="六、常用注解"><a href="#六、常用注解" class="headerlink" title="六、常用注解"></a>六、常用注解</h2><h3 id="1-Autowired用法详解"><a href="#1-Autowired用法详解" class="headerlink" title="1.@Autowired用法详解"></a>1.@Autowired用法详解</h3><p>@Autowired 注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired的使用来消除 set ，get方法。在使用@Autowired之前，我们对一个bean配置起属性时，是这样用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name&#x3D;&quot;属性名&quot; value&#x3D;&quot; 属性值&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>下面用案例来具体说明</p><p><strong>UserRepository.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 package com.proc.bean.repository;</span><br><span class="line">2 </span><br><span class="line">3 public interface UserRepository &#123;</span><br><span class="line">4     </span><br><span class="line">5     void save();</span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个User接口，其中定义了一个save方法</p><p><strong>UserRepositoryImps.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 package com.proc.bean.repository;</span><br><span class="line">2 </span><br><span class="line">3 import org.springframework.stereotype.Repository;</span><br><span class="line">4 </span><br><span class="line">5 @Repository(&quot;userRepository&quot;)</span><br><span class="line">6 public class UserRepositoryImps implements UserRepository&#123;</span><br><span class="line">7 </span><br><span class="line">8     @Override</span><br><span class="line">9     public void save() &#123;</span><br><span class="line">10         System.out.println(&quot;UserRepositoryImps save&quot;);</span><br><span class="line">11     &#125;</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure><p>定义一个UserRepository接口的实现类，并实现save方法，在这里指定了该bean在IoC中标识符名称为userRepository</p><p><strong>UserService.java</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 1 package com.proc.bean.service;</span><br><span class="line"> 2 </span><br><span class="line"> 3 import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"> 4 import org.springframework.stereotype.Service;</span><br><span class="line"> 5 </span><br><span class="line"> 6 import com.proc.bean.repository.UserRepository;</span><br><span class="line"> 7 </span><br><span class="line"> 8 @Service</span><br><span class="line"> 9 public class UserService &#123;</span><br><span class="line">10 </span><br><span class="line">11     @Autowired</span><br><span class="line">12     private UserRepository userRepository;</span><br><span class="line">13     </span><br><span class="line">14     public void save()&#123;</span><br><span class="line">15         userRepository.save();</span><br><span class="line">16     &#125;</span><br><span class="line">17 &#125;</span><br></pre></td></tr></table></figure><p>这里需要一个UserRepository类型的属性，通过@Autowired自动装配方式，从IoC容器中去查找到，并返回给该属性</p><p><strong>applicationContext.xml配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.proc.bean&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p><strong>测试代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 ApplicationContext ctx&#x3D;new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">2 </span><br><span class="line">3 UserService userService&#x3D;(UserService) ctx.getBean(&quot;userService&quot;);</span><br><span class="line">4 userService.save();</span><br></pre></td></tr></table></figure><p>输出结果：UserRepositoryImps save</p><p><strong>那么使用@Autowired的原理是什么？</strong></p><p>　　其实在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class&#x3D;&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>　　</p><p> <strong>注意事项：</strong></p><p>　　在使用@Autowired时，首先在容器中查询对应类型的bean</p><p>　    如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据</p><p>　　如果查询的结果不止一个，那么@Autowired会根据名称来查找。</p><p>　　如果查询的结果为空，那么会抛出异常。解决方法时，使用required=false</p><p>　　　　如果查询的结果不止一个，那么@Autowired会根据名称来查找。</p><p>　　　　如果查询的结果为空，那么会抛出异常。解决方法时，使用required=false</p><p>举例说明：</p><p> 在上面例子中，我们在定一个类来实现UserRepository接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.proc.bean.repository;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line">@Repository</span><br><span class="line">public class UserJdbcImps implements UserRepository &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;UserJdbcImps save&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这时在启动容器后，在容器中有两个UserRepository类型的实例，一个名称为userRepository，另一个为userJdbcImps。在UserService中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private UserRepository userRepository;</span><br></pre></td></tr></table></figure><p>　　输出结果：UserRepositoryImps save</p><p>　　这里由于查询到有两个该类型的实例，那么采用名称匹配方式，在容器中查找名称为userRepository的实例，并自动装配给该参数。</p><p>　　如果这里想要装载userJdbcImps的实例，除了将字段userRepository名称改成userJdbcImps外，可以提供了一个@Qualifier标记，来指定需要装配bean的名称，代码这样写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 @Autowired</span><br><span class="line">2 @Qualifier(&quot;userJdbcImps&quot;)</span><br><span class="line">3 private UserRepository userRepository;</span><br></pre></td></tr></table></figure><p>输出结果：UserJdbcImps save</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Maven" scheme="http://yoursite.com/categories/Maven/"/>
    
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>前端一些琐碎知识</title>
    <link href="http://yoursite.com/2020/04/19/Maven%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/04/19/Maven%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE/</id>
    <published>2020-04-19T13:26:35.210Z</published>
    <updated>2020-04-19T13:26:35.210Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="Maven-常用设置"><a href="#Maven-常用设置" class="headerlink" title="Maven 常用设置"></a>Maven 常用设置</h1><h2 id="packaging"><a href="#packaging" class="headerlink" title="packaging"></a>packaging</h2><p>项目的打包类型：pom、jar、war</p><p>packing默认是jar类型，</p><p><packaging>pom</packaging>  ———&gt;  父类型都为pom类型</p><p><packaging>jar</packaging>   ———&gt;  内部调用或者是作服务使用</p><p><packaging>war</packaging>  ———&gt;  需要部署的项目</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Maven" scheme="http://yoursite.com/categories/Maven/"/>
    
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript入门</title>
    <link href="http://yoursite.com/2020/04/19/JavaScript/"/>
    <id>http://yoursite.com/2020/04/19/JavaScript/</id>
    <published>2020-04-19T13:26:35.206Z</published>
    <updated>2020-04-19T13:26:35.206Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="1、JavaScript入门"><a href="#1、JavaScript入门" class="headerlink" title="1、JavaScript入门"></a>1、JavaScript入门</h1><h2 id="1-1、引入JavaScript"><a href="#1-1、引入JavaScript" class="headerlink" title="1.1、引入JavaScript"></a>1.1、引入JavaScript</h2><p>第一个程序hellword</p><p>内部标签与外部引入</p><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200315093240187.png"  alt="image-20200315093240187"></p><h2 id="1-2、基本语法入门"><a href="#1-2、基本语法入门" class="headerlink" title="1.2、基本语法入门"></a>1.2、基本语法入门</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(***);</span><br></pre></td></tr></table></figure><h2 id="1-3、控制台打印操作BOM对象"><a href="#1-3、控制台打印操作BOM对象" class="headerlink" title="1.3、控制台打印操作BOM对象"></a>1.3、控制台打印操作BOM对象</h2><blockquote><p>BOM：浏览器对象模型</p></blockquote><ul><li>IE 6-11</li><li>Chrome</li><li>safari</li><li>firefox</li><li>opera</li></ul><blockquote><p>window</p></blockquote><p>window代表浏览器窗口</p><blockquote><p>navigator</p></blockquote><p>封装了浏览器的信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator</span><br></pre></td></tr></table></figure><blockquote><p>screen</p></blockquote><p>代表屏幕尺寸</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">screen.width</span><br><span class="line"><span class="number">1366</span></span><br><span class="line">screen.height</span><br><span class="line"><span class="number">768</span></span><br></pre></td></tr></table></figure><blockquote><p>location</p></blockquote><p>location 代表当前页面的URL信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">host: &quot;www.bilibili.com&quot;</span><br><span class="line">hostname: &quot;www.bilibili.com&quot;</span><br><span class="line">href: &quot;https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;av82042680?p&#x3D;19&quot;</span><br><span class="line">protocol: &quot;https:&quot;</span><br><span class="line">reload: ƒ reload()&#x2F;&#x2F;刷新网页</span><br><span class="line">assign: ƒ assign()&#x2F;&#x2F;设置新的地址</span><br></pre></td></tr></table></figure><blockquote><p>document</p></blockquote><p>document代表当前的页面，html dom文档树</p><p>获取文档具体的文档树节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dl id=<span class="string">'app'</span>&gt;</span><br><span class="line">    &lt;td&gt;JVA&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">&lt;td&gt;JAVA&lt;/</span>td&gt;</span><br><span class="line">&lt;td&gt;JAVVV&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>dl&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> dl = <span class="built_in">document</span>.getElementId(<span class="string">"app"</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>获取cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.cookid</span><br><span class="line">&quot;_uuid&#x3D;30FC6DB5-3005-047D-32F2-1D694665D1EC80811infoc; buvid3&#x3D;F6323B87-F</span><br></pre></td></tr></table></figure><blockquote><p>history</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history.back()&#x2F;&#x2F;后退</span><br><span class="line">history.foward()&#x2F;&#x2F;前进</span><br></pre></td></tr></table></figure><h2 id="1-4、操作DOM对象"><a href="#1-4、操作DOM对象" class="headerlink" title="1.4、操作DOM对象"></a>1.4、操作DOM对象</h2><blockquote><p>核心</p></blockquote><p>浏览器网页就是一个dom属性结构</p><ul><li>更新：更新dom节点</li><li>便历dom节点 ：得到dom节点</li><li>删除</li><li>添加</li></ul><p>要操作一个dom节点，就必须先获得这个dom节点</p><blockquote><p>获取节点</p></blockquote><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200315120936018.png"  alt="image-20200315120936018"></p><blockquote><p>更新节点</p></blockquote><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200315122116240.png"  alt="image-20200315122116240"></p><blockquote><p>删除节点</p></blockquote><p>删除节点的步骤：先获取父节点，在通过父节点删除自己</p><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200315130847997.png"  alt="image-20200315130847997"></p><p>注意：删除多个节点的时候，childre是在时刻变化的，一定要注意</p><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200315131158384.png"  alt="image-20200315131158384"></p><blockquote><p> 插入节点 </p></blockquote><p>我们获得某个dom节点，假设这个dom节点是空的，我们通过innerHTML就可以增加一个元素了，但是这个dom已经存在元素了，我们就不能这么干了 ！会产生覆盖。</p><p>追加</p><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200315131848670.png"  alt="image-20200315131848670"></p><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200315133147980.png"  alt="image-20200315133147980"></p><h2 id="1-5、操作表单"><a href="#1-5、操作表单" class="headerlink" title="1.5、操作表单"></a>1.5、操作表单</h2><blockquote><p>表单是什么 from dom 树</p></blockquote><ul><li>文本框 text</li><li>下拉框 <select></li><li>单选框 radio</li><li>多选框 checkbox</li><li>隐藏域 hidden</li><li>密码框 password</li></ul><p>表单的目的：提交信息</p><p>获得要提交的信息</p><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200315134248130.png"  alt="image-20200315134248130"></p><blockquote><p>提交表单，md5加密密码，表单优化</p></blockquote><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200315175503148.png"  alt="image-20200315175503148"></p><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200315175539060.png"  alt="image-20200315175539060"></p><h2 id="1-6、jQuery"><a href="#1-6、jQuery" class="headerlink" title="1.6、jQuery"></a>1.6、jQuery</h2><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200315180316582.png"  alt="image-20200315180316582"></p><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200315180343053.png"  alt="image-20200315180343053"></p><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200315180730202.png"  alt="image-20200315180730202"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line">=$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);表示网页加载完毕之后，相应事件</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200315182103895.png"  alt="image-20200315182103895"></p><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200315182623795.png"  alt="image-20200315182623795"></p><p><img src="/" class="lazyload" data-src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200315182839937.png"  alt="image-20200315182839937"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>前端一些琐碎知识</title>
    <link href="http://yoursite.com/2020/04/19/DispatcherServlet%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2020/04/19/DispatcherServlet%E8%A7%A3%E8%AF%BB/</id>
    <published>2020-04-19T13:26:35.060Z</published>
    <updated>2020-04-19T13:26:35.060Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="DispatcherServlet解读"><a href="#DispatcherServlet解读" class="headerlink" title="DispatcherServlet解读"></a>DispatcherServlet解读</h1><p> SpringMVC的核心就是DispatcherServlet，DispatcherServlet实质也是一个HttpServlet。DispatcherSevlet负责将请求分发，所有的请求都有经过它来统一分发。</p><p>  大致看下SpringMVC请求处理的流程：<br><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20160512175121487"  alt="img"><br>  用户向服务器发送请求，请求会到DispatcherServlet，DispatcherServlet 对请求URL进行解析，得到请求资源标识符（URI），然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括一个Handler处理器对象、多个HandlerInterceptor拦截器对象），最后以HandlerExecutionChain对象的形式返回。<br>  DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p><ul><li>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</li><li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</li><li>数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</li><li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li></ul><p>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；根据返回的ModelAndView，选择一个适合的ViewResolver返回给DispatcherServlet；ViewResolver 结合Model和View，来渲染视图，最后将渲染结果返回给客户端。</p><h2 id="requestMapping-根据请求路径获取对应处理方法"><a href="#requestMapping-根据请求路径获取对应处理方法" class="headerlink" title="requestMapping-根据请求路径获取对应处理方法"></a>requestMapping-根据请求路径获取对应处理方法</h2><h3 id="一、重要的类和接口"><a href="#一、重要的类和接口" class="headerlink" title="一、重要的类和接口"></a>一、重要的类和接口</h3><ol><li>HandlerMethodArgumentResolver 一个策略接口，根据请求解析处理方法的参数值（这是重点），我们就是通过实现它来自定义我们的参数类型的。Spring默认提供了十多个类型的解析器来处理常见的方法参数，如@PathVariabe，@RequestParam， Model，@ModelAttribute等等。</li><li>HandlerMethodReturnValueHandler 一个策略接口，用来处理处理器方法的返回值(重点啊)， 我们通过实现它来自定义我们的返回类型</li><li>RequestMappingHandlerAdapter 一个HandlerAdapter的实现类，用来处理HandlerMethod，它包含了上面两个接口一系列实现类的列表，用于处理不同的参数和返回类型</li><li>HandlerMethodArgumentResolverComposite 这个类 维护了一个MethodParameter 与 HandlerMethodArgumentResolver的映射表，可以快速检索某一MethodParameter对应的Resolver，并调用Resolver进行参数解析。</li><li>HandlerMethodReturnValueHandlerComposite 这个类只维护了一个所有HandlerMethodReturnValueHandler的列表，每次遍历检索支持某返回类型的处理器。</li><li>ModelAndViewContainer 这个类记录了Model和View的对应关系，可快速检索某个视图对应的Model。</li></ol><p>说明：当我们阅读@RequestMapping注解的说明时会了解到，Spring的处理器方法默认支持诸多参数类型和返回值类型，并提供了每一个参数类型，返回值类型的解析器和处理器，上述1,2两个接口的实现类，我们大致看一下他们的类层次结构：</p><p><img src="/" class="lazyload" data-src="http://static.oschina.net/uploads/space/2014/0330/144924_lbqN_258230.png"  alt="img"></p><p><img src="/" class="lazyload" data-src="http://static.oschina.net/uploads/space/2014/0330/144944_3CqX_258230.png"  alt="img"></p><p>  以上是方法参数的可能类型以及他们的解析器，Spring默认支持还是挺棒的，可以应付绝大多数需求了。</p><p><img src="/" class="lazyload" data-src="http://static.oschina.net/uploads/space/2014/0330/145132_jtRf_258230.png"  alt="img"></p><p><img src="/" class="lazyload" data-src="http://static.oschina.net/uploads/space/2014/0330/145150_5Vp2_258230.png"  alt="img"></p><p>  以上是可能的返回值类型和他们的处理器，同样Spring的默认支持很强大，我们都可以实现自己的参数解析器和返回值处理器。</p><p>  我们可以看到支持的类型非常多，由于篇幅限制，我们只讲解最常用的一个或几个，如@PathVariable，@RequestParam，Model等，如果有兴趣大家可以自行研究，思路都一样。</p><h3 id="二、找到请求对应的处理方法"><a href="#二、找到请求对应的处理方法" class="headerlink" title="二、找到请求对应的处理方法"></a>二、找到请求对应的处理方法</h3><p>  我们知道Spring会通过DispatcherServlet来处理所有的请求，那么我们就看他是怎么处理的：</p><p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p><ol><li><strong>protected</strong> <strong>void</strong> doDispatch(HttpServletRequest request, HttpServletResponse response) { </li><li>​    HttpServletRequest processedRequest = request; </li><li>​    HandlerExecutionChain mappedHandler = <strong>null</strong>; </li><li>​    AsyncExecutionChain asyncChain = AsyncExecutionChain.getForCurrentRequest(request); </li><li>​    <strong>try</strong> { </li><li>​      ModelAndView mv = <strong>null</strong>; </li><li>​      Exception dispatchException = <strong>null</strong>; </li><li>​      <strong>try</strong> { </li><li>​        processedRequest = checkMultipart(request); </li><li>​        // 确定当前请求的处理器（HandlerExecutionChain 包含Handler和Interceptor列表） </li><li>​        mappedHandler = getHandler(processedRequest, <strong>false</strong>); </li><li>​        <strong>if</strong> (mappedHandler == <strong>null</strong> || mappedHandler.getHandler() == <strong>null</strong>) { </li><li>​          noHandlerFound(processedRequest, response);//404异常 </li><li>​          <strong>return</strong>; </li><li>​        } </li><li>​        // 确定当前请求的处理器适配器 </li><li>​        HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); </li><li>​        //……省略诸多代码…… </li><li>​        // 调用处理处理器方法，返回ModelAndView对象 </li><li>​        mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); </li><li>​      }//处理返回结果 </li><li>​    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); </li><li>​    } </li><li>} </li></ol><p>  相信这个方法大家都很熟了，我删除了一些与当前主体无关的代码，下面我们看getHandler是怎么做的：</p><p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p><ol><li><strong>protected</strong> HandlerExecutionChain getHandler(HttpServletRequest request) <strong>throws</strong> Exception { </li><li>​    //这里有一个handlerMappings实例变量，如果你看过<a href="mvc:annotation-driven/">mvc:annotation-driven/</a>那篇文章，相信你就知道这 </li><li>​    //个handlerMappings都包括哪些HandlerMapping实例了？ </li><li>​    <strong>for</strong> (HandlerMapping hm : <strong>this</strong>.handlerMappings) { </li><li>​      HandlerExecutionChain handler = hm.getHandler(request); </li><li>​      <strong>if</strong> (handler != <strong>null</strong>) { </li><li>​        <strong>return</strong> handler; </li><li>​      } </li><li>​    } </li><li>​    <strong>return</strong> <strong>null</strong>; </li><li>} </li></ol><p>  <a href="http://blog.csdn.net/J080624/article/details/56276785" target="_blank" rel="noopener">这篇博客</a> 中说明了在启用该标签时Spring会默认注册RequestMappingHandlerMapping实例在处理@RequestMapping注解，而<a href="http://blog.csdn.net/j080624/article/details/56278461" target="_blank" rel="noopener">@RequestMapping (1)</a><a href="http://blog.csdn.net/j080624/article/details/56278461" target="_blank" rel="noopener"> </a>这篇博客说明了该HandlerMapping是如何处理@RequestMapping注解，以及怎么保存请求映射关系的。下面我们就看RequestMappingHandlerMapping的getHandler方法：</p><p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p><ol><li>//….. </li><li>//AbstractHandlerMapping </li><li>//….. </li><li><strong>public</strong> <strong>final</strong> HandlerExecutionChain getHandler(HttpServletRequest request) <strong>throws</strong> Exception { </li><li>​    Object handler = getHandlerInternal(request);//调用下面的方法 </li><li>​    <strong>if</strong> (handler == <strong>null</strong>) { </li><li>​      handler = getDefaultHandler(); </li><li>​    } </li><li>​    <strong>if</strong> (handler == <strong>null</strong>) { </li><li>​      <strong>return</strong> <strong>null</strong>; </li><li>​    } </li><li>​    // Bean name or resolved handler? </li><li>​    <strong>if</strong> (handler <strong>instanceof</strong> String) { </li><li>​      String handlerName = (String) handler; </li><li>​      handler = getApplicationContext().getBean(handlerName); </li><li>​    }//返回该请求对应的HandlerExecutionChain（包括处理器方法和拦截器） </li><li>​    <strong>return</strong> getHandlerExecutionChain(handler, request); </li><li>} </li><li>//….. </li><li>//AbstractHandlerMethodMapping(RequestMappingHandlerMapping 的祖先类) </li><li>//返回值是HandlerMethod </li><li>//….. </li><li>@Override </li><li><strong>protected</strong> HandlerMethod getHandlerInternal(HttpServletRequest request) <strong>throws</strong> Exception { </li><li>​    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request); </li><li>​    ///查找请求路径对应的HandlerMethod实例 </li><li>​    HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request); </li><li>​    //确保HandlerMethod中的handler是处理器实例而不是处理器名字 </li><li>​    <strong>return</strong> (handlerMethod != <strong>null</strong>) ? handlerMethod.createWithResolvedBean() : <strong>null</strong>; </li><li>} </li></ol><p>以上两个方法都是RequestMappingHandlerMapping的祖先类，逻辑很简单，先获取当前请求的路径，然后查找该路径对应的HandlerMethod实例。<a href="http://blog.csdn.net/j080624/article/details/56278461" target="_blank" rel="noopener">@RequestMapping (1)</a> 这篇博客最后讲到了，RequestMappingHandlerMapping中的两个映射表实例，urlMap和handlerMethods，第一个是路径与RequestMappingInfo的映射，第二个是RequestMappingInfo和HandlerMethod的映射，不用说，lookupHandlerMethod方法肯定是检索这两个变量了:</p><p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p><ol><li><strong>protected</strong> HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request){ </li><li>​    List<Match> matches = <strong>new</strong> ArrayList<Match>(); </li><li>​    //查找urlMap，获取直接匹配的RequestMappingInfo列表。如 </li><li>​    //URL 是/work/produce/2， @RequestMapping（”/work/produce/2”)直接匹配 </li><li>​    List<T> directPathMatches = <strong>this</strong>.urlMap.get(lookupPath); </li><li>​    <strong>if</strong> (directPathMatches != <strong>null</strong>) { </li><li>​      addMatchingMappings(directPathMatches, matches, request); </li><li>​    } </li><li>​    <strong>if</strong> (matches.isEmpty()) {//如果没有找到直接匹配项，遍历所有的注册的RequestMappingInfo来查找 </li><li>​      //遍历所有可能的RequestMappingInfo，找到完全匹配的RequestMappingInfo实例，并生成Match对象 </li><li>​      //添加到Match列表中，Match是RequestMappingInfo和HandlerMethod的临时映射表。 </li><li>​      //举个例子：请求URL可能是GET:/work/produce/2, </li><li>​      //而@RequestMapping(“/work/produce/{no}” “GET”)此时需要匹配是否是GET请求，以及模式是否匹配 </li><li>​      addMatchingMappings(<strong>this</strong>.handlerMethods.keySet(), matches, request); </li><li>​    } </li><li>​    <strong>if</strong> (!matches.isEmpty()) {//排序，找出最佳匹配 </li><li>​      Comparator<Match> comparator = <strong>new</strong> MatchComparator(getMappingComparator(request)); </li><li>​      Collections.sort(matches, comparator); </li><li>​      Match bestMatch = matches.get(0); </li><li>​      <strong>if</strong> (matches.size() &gt; 1) {//如果可能的方法多余一个 </li><li>​        Match secondBestMatch = matches.get(1);//并且两个方法的@RequestMapping内容相同 </li><li>​        <strong>if</strong> (comparator.compare(bestMatch, secondBestMatch) == 0) {//抛出异常 </li><li>​          Method m1 = bestMatch.handlerMethod.getMethod(); </li><li>​          Method m2 = secondBestMatch.handlerMethod.getMethod(); </li><li>​          <strong>throw</strong> <strong>new</strong> IllegalStateException( </li><li>​              “Ambiguous handler methods mapped for HTTP path”); </li><li>​        } </li><li>​      } </li><li>​      //这里是处理请求路径中的变量，如果/work/produce/{no}匹配的/work/produce/2中将no=2 </li><li>​      //添加到Request的属性表中，以便后面@PathVarible参数的处理 </li><li>​      handleMatch(bestMatch.mapping, lookupPath, request); </li><li>​      <strong>return</strong> bestMatch.handlerMethod; </li><li>​    } </li><li>​    <strong>else</strong> { </li><li>​      <strong>return</strong> handleNoMatch(handlerMethods.keySet(), lookupPath, request); </li><li>​    } </li><li>} </li></ol><p>  在进行URL匹配中，Spring会先查找是否存在直接匹配的RequestMappingInfo实例，即@RequestMapping中的value，method属性完全匹配请求的，如果没有找到通常是存在PathVariable的，如果上面讲的/{no}和/222的情况等也是匹配的, 找到匹配项后，需要找出最优解，然后将路径中的变量存入Request的变量表中，我们分别详细的了解下：</p><p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p><ol><li><strong>private</strong> <strong>void</strong> addMatchingMappings(Collection<T> mappings, List<Match> matches,  </li><li>​                                HttpServletRequest request) { </li><li>​    <strong>for</strong> (T mapping : mappings) {//遍历所有的RequestMappingInfo列表 </li><li>​      T match = getMatchingMapping(mapping, request);//获取匹配的RequestMappingInfo实例 </li><li>​      <strong>if</strong> (match != <strong>null</strong>) {//并生成匹配的RequestMappingInfo实例和对应HandlerMethod的Match实例 </li><li>​        matches.add(<strong>new</strong> Match(match, handlerMethods.get(mapping))); </li><li>​      } </li><li>​    } </li><li>} </li></ol><p>  继续看getMatchingMapping的实现：</p><p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p><ol><li><strong>public</strong> RequestMappingInfo getMatchingCondition(HttpServletRequest request) { </li><li>​    //查看RequestMappingInfo的所有属性是否匹配 </li><li>​    RequestMethodsRequestCondition methods = methodsCondition.getMatchingCondition(request); </li><li>​    ParamsRequestCondition params = paramsCondition.getMatchingCondition(request); </li><li>​    HeadersRequestCondition headers = headersCondition.getMatchingCondition(request); </li><li>​    ConsumesRequestCondition consumes = consumesCondition.getMatchingCondition(request); </li><li>​    ProducesRequestCondition produces = producesCondition.getMatchingCondition(request); </li><li>​    <strong>if</strong> (methods == <strong>null</strong> || params == <strong>null</strong> || headers == <strong>null</strong>  </li><li>​                          || consumes == <strong>null</strong> || produces == <strong>null</strong>) { </li><li>​      <strong>return</strong> <strong>null</strong>; </li><li>​    }//我们重点看这个，路径是否匹配 </li><li>​    PatternsRequestCondition patterns = patternsCondition.getMatchingCondition(request); </li><li>​    <strong>if</strong> (patterns == <strong>null</strong>) { </li><li>​      <strong>return</strong> <strong>null</strong>; </li><li>​    } </li><li>​    RequestConditionHolder custom = customConditionHolder.getMatchingCondition(request); </li><li>​    <strong>if</strong> (custom == <strong>null</strong>) { </li><li>​      <strong>return</strong> <strong>null</strong>; </li><li>​    } </li><li>​    <strong>return</strong> <strong>new</strong> RequestMappingInfo(patterns, methods, params, headers,  </li><li>​                            produces, custom.getCondition()); </li><li>} </li></ol><p>  我们知道RequestMappingInfo就是@RequestMapping注解的抽象，它包含@RequestMapping中的所有属性，因此在查找匹配项时，需要查看所有这些属性是否与请求匹配。我们这里只看路径模式是否匹配，其他属性自行研究，都很简单：</p><p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p><ol><li><strong>public</strong> PatternsRequestCondition getMatchingCondition(HttpServletRequest request) { </li><li>​    <strong>if</strong> (<strong>this</strong>.patterns.isEmpty()) { </li><li>​      <strong>return</strong> <strong>this</strong>; </li><li>​    }//获取请求路径如/work/produce/2 </li><li>​    String lookupPath = <strong>this</strong>.urlPathHelper.getLookupPathForRequest(request); </li><li>​    List<String> matches = <strong>new</strong> ArrayList<String>(); </li><li>​    //遍历@RequestMapping中的所有模式 </li><li>​    <strong>for</strong> (String pattern : patterns) { </li><li>​      //找出与请求路径匹配的模式，如/work/produce/{no} </li><li>​      String match = getMatchingPattern(pattern, lookupPath); </li><li>​      <strong>if</strong> (match != <strong>null</strong>) { </li><li>​        matches.add(match); </li><li>​      } </li><li>​    }//排序 </li><li>​    Collections.sort(matches, <strong>this</strong>.pathMatcher.getPatternComparator(lookupPath)); </li><li>​    //返回匹配的请求模式实例 </li><li>​    <strong>return</strong> matches.isEmpty() ? <strong>null</strong> :  </li><li>​      <strong>new</strong> PatternsRequestCondition(matches, <strong>this</strong>.urlPathHelper, <strong>this</strong>.pathMatcher,  </li><li>​                    <strong>this</strong>.useSuffixPatternMatch, <strong>this</strong>.useTrailingSlashMatch); </li><li>} </li><li></li><li><strong>private</strong> String getMatchingPattern(String pattern, String lookupPath) { </li><li>​    <strong>if</strong> (pattern.equals(lookupPath)) { </li><li>​      <strong>return</strong> pattern;//直接匹配 </li><li>​    } </li><li>​    <strong>if</strong> (<strong>this</strong>.useSuffixPatternMatch) {//是否使用后缀模式，/abc/de匹配/abc </li><li>​      <strong>boolean</strong> hasSuffix = pattern.indexOf(‘.’) != -1; </li><li>​      <strong>if</strong> (!hasSuffix &amp;&amp; <strong>this</strong>.pathMatcher.match(pattern + “.*”, lookupPath)) { </li><li>​        <strong>return</strong> pattern + “.*”; </li><li>​      } </li><li>​    }//匹配/work/produce/{no} 和/work/produce/2 </li><li>​    <strong>if</strong> (<strong>this</strong>.pathMatcher.match(pattern, lookupPath)) { </li><li>​      <strong>return</strong> pattern; </li><li>​    }//是否使用结尾的斜线匹配 </li><li>​    <strong>boolean</strong> endsWithSlash = pattern.endsWith(“/“); </li><li>​    <strong>if</strong> (<strong>this</strong>.useTrailingSlashMatch) { </li><li>​      <strong>if</strong> (!endsWithSlash &amp;&amp; <strong>this</strong>.pathMatcher.match(pattern + “/“, lookupPath)) { </li><li>​        <strong>return</strong> pattern +”/“; </li><li>​      } </li><li>​    } </li><li>​    <strong>return</strong> <strong>null</strong>; </li><li>} </li></ol><p>  至于上面的pathMatcher.match方法这里就不分析了，可以自己看看，匹配算法还是比较复杂的，主要是尽可能的全面，除了进行匹配外，还会将路径中的变量保存起来以便@PathVariable参数使用。</p><p>  以上便是整个的匹配过好麻烦，或许你会说这会不会降低Spring的性能？实话说，在处理首次请求时，效率是很差，但是Spring使用了各种缓存策略，一旦程序进入正轨，效率就非常高了。</p><h3 id="三、处理器方法的调用"><a href="#三、处理器方法的调用" class="headerlink" title="三、处理器方法的调用"></a>三、处理器方法的调用</h3><p>  现在我们已经查找到了对应请求的处理器方法，下面我们就看Spring是如何在运行时动态地调用处理器方法的，并传递正确的参数。在doDispatch方法中，我们看到，确定了处理器（方法）后，Spring接着获取了该处理器方法的适配器（HandlerAdapter概念讲解中说到过，用来调用处理器方法的）</p><p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p><ol><li><strong>protected</strong> HandlerAdapter getHandlerAdapter(Object handler) <strong>throws</strong> ServletException { </li><li>​    //这个handlerAdapters跟handlerMappings一样，启用<a href="mvc:annoation-driven/">mvc:annoation-driven/</a>后默认注册 </li><li>​    //RequestMappingHandlerAdapter（since3.1） </li><li>​    <strong>for</strong> (HandlerAdapter ha : <strong>this</strong>.handlerAdapters) { </li><li>​      <strong>if</strong> (ha.supports(handler)) { </li><li>​        <strong>return</strong> ha; </li><li>​      } </li><li>​    } </li><li>​    <strong>throw</strong> <strong>new</strong> ServletException(“No adapter for handler [“ + handler + </li><li>​        “]: Does your handler implement a supported interface like Controller?”); </li><li>} </li><li>//是否支持当前处理器，其实就是看看处理器是不是HandlerMethod实例 </li><li><strong>public</strong> <strong>final</strong> <strong>boolean</strong> supports(Object handler) { </li><li>​    <strong>return</strong> handler <strong>instanceof</strong> HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler); </li><li>} </li></ol><p>  获取了HandlerAdapter后，Spring就会调用handlerAdapter实例的handle方法，并返回ModelAndView实例：</p><p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p><ol><li>@Override </li><li><strong>protected</strong> <strong>final</strong> ModelAndView handleInternal(HttpServletRequest request, </li><li>​      HttpServletResponse response, HandlerMethod handlerMethod) <strong>throws</strong> Exception { </li><li>​    //如果HandlerMethod所属的处理器被@SessionAttribute注解标记了 </li><li>​    <strong>if</strong> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) { </li><li>​     //设置响应头信息，防止缓存以便Session属性的管理 </li><li>​     checkAndPrepare(request, response, <strong>this</strong>.cacheSecondsForSessionAttributeHandlers, <strong>true</strong>); </li><li>​    } </li><li>​    <strong>else</strong> { </li><li>​      //设置响应头，缓存默认时间 </li><li>​      checkAndPrepare(request, response, <strong>true</strong>); </li><li>​    } </li><li>​    //要求在Session级别上进行同步，即同一个客户端的多个请求需要阻塞调用该处理器方法 </li><li>​    <strong>if</strong> (<strong>this</strong>.synchronizeOnSession) { </li><li>​      HttpSession session = request.getSession(<strong>false</strong>); </li><li>​      <strong>if</strong> (session != <strong>null</strong>) { </li><li>​        Object mutex = WebUtils.getSessionMutex(session); </li><li>​        <strong>synchronized</strong> (mutex) {//调用 </li><li>​          <strong>return</strong> invokeHandleMethod(request, response, handlerMethod); </li><li>​        } </li><li>​      } </li><li>​    }//调用 </li><li>​    <strong>return</strong> invokeHandleMethod(request, response, handlerMethod); </li><li>} </li></ol><p>  我们接着看invokeHandlerMethod方法：</p><p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p><ol><li><strong>private</strong> ModelAndView invokeHandleMethod(HttpServletRequest request, </li><li>​      HttpServletResponse response, HandlerMethod handlerMethod) <strong>throws</strong> Exception { </li><li>​    //包装请求和响应对象 </li><li>​    ServletWebRequest webRequest = <strong>new</strong> ServletWebRequest(request, response); </li><li>​    //获取与HandlerMethod对应的DataBinderFactory。 </li><li>​    WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); </li><li>​    //获取处理器方法所属处理器中被@ModelAttribute标记，但是没有被@RequestMapping标记的方法 </li><li>​    ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); </li><li>​    //创建请求映射方法，并将HandlerAdapter中的参数解析器列表和返回值处理器列表传递给它。 </li><li>​    ServletInvocableHandlerMethod requestMappingMethod =  </li><li>​                   createRequestMappingMethod(handlerMethod, binderFactory); </li><li>​    //创建ModelAndViewContainer </li><li>​    ModelAndViewContainer mavContainer = <strong>new</strong> ModelAndViewContainer(); </li><li>​    mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request)); </li><li>​    modelFactory.initModel(webRequest, mavContainer, requestMappingMethod); </li><li>​    mavContainer.setIgnoreDefaultModelOnRedirect(<strong>this</strong>.ignoreDefaultModelOnRedirect); </li><li>​    //获取并设置当前请求的异步调用链实例 </li><li>​    AsyncExecutionChain chain = AsyncExecutionChain.getForCurrentRequest(request); </li><li>​    chain.addDelegatingCallable(getAsyncCallable(mavContainer, modelFactory, webRequest)); </li><li>​    chain.setAsyncWebRequest(createAsyncWebRequest(request, response)); </li><li>​    chain.setTaskExecutor(<strong>this</strong>.taskExecutor); </li><li>​    //调用该处理器方法。 </li><li>​    requestMappingMethod.invokeAndHandle(webRequest, mavContainer); </li><li></li><li>​    <strong>if</strong> (chain.isAsyncStarted()) { </li><li>​      <strong>return</strong> <strong>null</strong>; </li><li>​    } </li><li>​    //获取并返回ModelAndView </li><li>​    <strong>return</strong> getModelAndView(mavContainer, modelFactory, webRequest); </li><li>} </li></ol><p>  关于异步调用链那块我们暂不关心，后续文章会专题讨论。从上面代码可以看到，在调用方法前，分别检查了处理器中存在的@InitBinder注解的方法和@ModelAttribute注解的方法，InitBinder方法用于类型转化，如将String转化为Date类型等，可以通过@InitBinder方法实现，感兴趣可以自己看看，不在详细分析。至于@ModelAttribute注解的方法，其返回值会被放入Model对象中供视图使用。下面我们看invokeAndHandle方法：</p><p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p><ol><li><strong>public</strong> <strong>final</strong> <strong>void</strong> invokeAndHandle(ServletWebRequest webRequest, </li><li>​      ModelAndViewContainer mavContainer, Object… providedArgs) <strong>throws</strong> Exception { </li><li>​    //….省略异步调用方法，暂不考虑 </li><li>​    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); </li><li>​    //….省略几行代码，暂不考虑 </li><li>​    <strong>try</strong> {//处理返回结果 </li><li>​      <strong>this</strong>.returnValueHandlers.handleReturnValue(returnValue,  </li><li>​                  getReturnValueType(returnValue), mavContainer, webRequest); </li><li>​    } </li><li>} </li></ol><p>  接着我们看下invokeForRequest方法：—-we are so close.</p><p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p><ol><li><strong>public</strong> <strong>final</strong> Object invokeForRequest(NativeWebRequest request, </li><li>​                     ModelAndViewContainer mavContainer, </li><li>​                     Object… providedArgs) <strong>throws</strong> Exception { </li><li>​    //获取方法参数值。 </li><li>​    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); </li><li>​    //传递参数值，调用，返回返回值 </li><li>​    Object returnValue = invoke(args); </li><li>​    <strong>return</strong> returnValue; </li><li>} </li></ol><p>  啊哈上面的代码貌似很简单，实则不是，重点就在getMethodArgumentValues方法，这才是我们这片文章的真正主题呢。打起精神来了：</p><p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p><ol><li><strong>private</strong> Object[] getMethodArgumentValues( </li><li>​      NativeWebRequest request, ModelAndViewContainer mavContainer, </li><li>​      Object… providedArgs) <strong>throws</strong> Exception { </li><li>​    //获取处理器方法的MethodParameter数组，就是方法的“参数定义”列表。 </li><li>​    MethodParameter[] parameters = getMethodParameters(); </li><li>​    Object[] args = <strong>new</strong> Object[parameters.length]; </li><li>​    //遍历所有方法参数 </li><li>​    <strong>for</strong> (<strong>int</strong> i = 0; i &lt; parameters.length; i++) { </li><li>​      MethodParameter parameter = parameters[i]; </li><li>​      parameter.initParameterNameDiscovery(parameterNameDiscoverer); </li><li>​      //确定泛型参数的类型 </li><li>​      GenericTypeResolver.resolveParameterType(parameter, getBean().getClass()); </li><li>​      //根据提供的参数值，解析当前参数的值 </li><li>​      args[i] = resolveProvidedArgument(parameter, providedArgs); </li><li>​      <strong>if</strong> (args[i] != <strong>null</strong>) { </li><li>​        <strong>continue</strong>; </li><li>​      } </li><li>​      //根据内置的参数解析器（上面的图片中列出了），来解析当前的参数值 </li><li>​      <strong>if</strong> (argumentResolvers.supportsParameter(parameter)) { </li><li>​        <strong>try</strong> { </li><li>​          args[i] = argumentResolvers.resolveArgument(parameter, mavContainer, </li><li>​                                 request, dataBinderFactory); </li><li>​          <strong>continue</strong>; </li><li>​        } </li><li>​      } </li><li>​      //如果参数值依旧为空，抛出异常。 </li><li>​      <strong>if</strong> (args[i] == <strong>null</strong>) { </li><li>​     String msg = getArgumentResolutionErrorMessage(“No suitable resolver for argument”, i); </li><li>​     <strong>throw</strong> <strong>new</strong> IllegalStateException(msg); </li><li>​      } </li><li>​    } </li><li>​    <strong>return</strong> args; </li><li>} </li></ol><p>  该方法是HandlerMethod中的方法，因此可以调用getMethodParameters()方法获取参数列表，然后遍历这些参数，分别用参数解析器来解析当前参数值，其中，argumentResolvers是HandlerMethodArgumentResolverComposite，概念讲解中已经阐述，它包含了所有的参数解析器的列表，以及参数类型和解析器的映射表，我们不妨看看到底什么怎么回事：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="SpringMVC" scheme="http://yoursite.com/categories/SpringMVC/"/>
    
    
      <category term="DispatcherServlet" scheme="http://yoursite.com/tags/DispatcherServlet/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/04/19/hello-world/"/>
    <id>http://yoursite.com/2020/04/19/hello-world/</id>
    <published>2020-04-19T11:32:27.805Z</published>
    <updated>2020-04-19T11:32:27.802Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
