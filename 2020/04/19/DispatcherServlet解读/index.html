<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>DispatcherServlet解读 | FlyingSnows</title><meta name="description" content="DispatcherServlet解读"><meta name="keywords" content="DispatcherServlet"><meta name="author" content="王志强"><meta name="copyright" content="王志强"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="DispatcherServlet解读"><meta name="twitter:description" content="DispatcherServlet解读"><meta name="twitter:image" content="http://yoursite.com/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="DispatcherServlet解读"><meta property="og:url" content="http://yoursite.com/2020/04/19/DispatcherServlet%E8%A7%A3%E8%AF%BB/"><meta property="og:site_name" content="FlyingSnows"><meta property="og:description" content="DispatcherServlet解读"><meta property="og:image" content="http://yoursite.com/img/post.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/04/19/DispatcherServlet%E8%A7%A3%E8%AF%BB/"><link rel="prev" title="JavaScript入门" href="http://yoursite.com/2020/04/19/JavaScript/"><link rel="next" title="Hello World" href="http://yoursite.com/2020/04/19/hello-world/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="FlyingSnows" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/playlist/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DispatcherServlet解读"><span class="toc-number">1.</span> <span class="toc-text">DispatcherServlet解读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#requestMapping-根据请求路径获取对应处理方法"><span class="toc-number">1.1.</span> <span class="toc-text">requestMapping-根据请求路径获取对应处理方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、重要的类和接口"><span class="toc-number">1.1.1.</span> <span class="toc-text">一、重要的类和接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、找到请求对应的处理方法"><span class="toc-number">1.1.2.</span> <span class="toc-text">二、找到请求对应的处理方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、处理器方法的调用"><span class="toc-number">1.1.3.</span> <span class="toc-text">三、处理器方法的调用</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">FlyingSnows</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/playlist/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">DispatcherServlet解读</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-04-19 21:32:45"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-04-19</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-04-19 21:32:45"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-04-19</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/SpringMVC/">SpringMVC</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="DispatcherServlet解读"><a href="#DispatcherServlet解读" class="headerlink" title="DispatcherServlet解读"></a>DispatcherServlet解读</h1><p> SpringMVC的核心就是DispatcherServlet，DispatcherServlet实质也是一个HttpServlet。DispatcherSevlet负责将请求分发，所有的请求都有经过它来统一分发。</p>
<p>  大致看下SpringMVC请求处理的流程：<br><img src="/" class="lazyload" data-src="https://img-blog.csdn.net/20160512175121487"  alt="img"><br>  用户向服务器发送请求，请求会到DispatcherServlet，DispatcherServlet 对请求URL进行解析，得到请求资源标识符（URI），然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括一个Handler处理器对象、多个HandlerInterceptor拦截器对象），最后以HandlerExecutionChain对象的形式返回。<br>  DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p>
<ul>
<li>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</li>
<li>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</li>
<li>数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li>
</ul>
<p>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；根据返回的ModelAndView，选择一个适合的ViewResolver返回给DispatcherServlet；ViewResolver 结合Model和View，来渲染视图，最后将渲染结果返回给客户端。</p>
<h2 id="requestMapping-根据请求路径获取对应处理方法"><a href="#requestMapping-根据请求路径获取对应处理方法" class="headerlink" title="requestMapping-根据请求路径获取对应处理方法"></a>requestMapping-根据请求路径获取对应处理方法</h2><h3 id="一、重要的类和接口"><a href="#一、重要的类和接口" class="headerlink" title="一、重要的类和接口"></a>一、重要的类和接口</h3><ol>
<li>HandlerMethodArgumentResolver 一个策略接口，根据请求解析处理方法的参数值（这是重点），我们就是通过实现它来自定义我们的参数类型的。Spring默认提供了十多个类型的解析器来处理常见的方法参数，如@PathVariabe，@RequestParam， Model，@ModelAttribute等等。</li>
<li>HandlerMethodReturnValueHandler 一个策略接口，用来处理处理器方法的返回值(重点啊)， 我们通过实现它来自定义我们的返回类型</li>
<li>RequestMappingHandlerAdapter 一个HandlerAdapter的实现类，用来处理HandlerMethod，它包含了上面两个接口一系列实现类的列表，用于处理不同的参数和返回类型</li>
<li>HandlerMethodArgumentResolverComposite 这个类 维护了一个MethodParameter 与 HandlerMethodArgumentResolver的映射表，可以快速检索某一MethodParameter对应的Resolver，并调用Resolver进行参数解析。</li>
<li>HandlerMethodReturnValueHandlerComposite 这个类只维护了一个所有HandlerMethodReturnValueHandler的列表，每次遍历检索支持某返回类型的处理器。</li>
<li>ModelAndViewContainer 这个类记录了Model和View的对应关系，可快速检索某个视图对应的Model。</li>
</ol>
<p>说明：当我们阅读@RequestMapping注解的说明时会了解到，Spring的处理器方法默认支持诸多参数类型和返回值类型，并提供了每一个参数类型，返回值类型的解析器和处理器，上述1,2两个接口的实现类，我们大致看一下他们的类层次结构：</p>
<p><img src="/" class="lazyload" data-src="http://static.oschina.net/uploads/space/2014/0330/144924_lbqN_258230.png"  alt="img"></p>
<p><img src="/" class="lazyload" data-src="http://static.oschina.net/uploads/space/2014/0330/144944_3CqX_258230.png"  alt="img"></p>
<p>  以上是方法参数的可能类型以及他们的解析器，Spring默认支持还是挺棒的，可以应付绝大多数需求了。</p>
<p><img src="/" class="lazyload" data-src="http://static.oschina.net/uploads/space/2014/0330/145132_jtRf_258230.png"  alt="img"></p>
<p><img src="/" class="lazyload" data-src="http://static.oschina.net/uploads/space/2014/0330/145150_5Vp2_258230.png"  alt="img"></p>
<p>  以上是可能的返回值类型和他们的处理器，同样Spring的默认支持很强大，我们都可以实现自己的参数解析器和返回值处理器。</p>
<p>  我们可以看到支持的类型非常多，由于篇幅限制，我们只讲解最常用的一个或几个，如@PathVariable，@RequestParam，Model等，如果有兴趣大家可以自行研究，思路都一样。</p>
<h3 id="二、找到请求对应的处理方法"><a href="#二、找到请求对应的处理方法" class="headerlink" title="二、找到请求对应的处理方法"></a>二、找到请求对应的处理方法</h3><p>  我们知道Spring会通过DispatcherServlet来处理所有的请求，那么我们就看他是怎么处理的：</p>
<p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>protected</strong> <strong>void</strong> doDispatch(HttpServletRequest request, HttpServletResponse response) { </li>
<li>​    HttpServletRequest processedRequest = request; </li>
<li>​    HandlerExecutionChain mappedHandler = <strong>null</strong>; </li>
<li>​    AsyncExecutionChain asyncChain = AsyncExecutionChain.getForCurrentRequest(request); </li>
<li>​    <strong>try</strong> { </li>
<li>​      ModelAndView mv = <strong>null</strong>; </li>
<li>​      Exception dispatchException = <strong>null</strong>; </li>
<li>​      <strong>try</strong> { </li>
<li>​        processedRequest = checkMultipart(request); </li>
<li>​        // 确定当前请求的处理器（HandlerExecutionChain 包含Handler和Interceptor列表） </li>
<li>​        mappedHandler = getHandler(processedRequest, <strong>false</strong>); </li>
<li>​        <strong>if</strong> (mappedHandler == <strong>null</strong> || mappedHandler.getHandler() == <strong>null</strong>) { </li>
<li>​          noHandlerFound(processedRequest, response);//404异常 </li>
<li>​          <strong>return</strong>; </li>
<li>​        } </li>
<li>​        // 确定当前请求的处理器适配器 </li>
<li>​        HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); </li>
<li>​        //……省略诸多代码…… </li>
<li>​        // 调用处理处理器方法，返回ModelAndView对象 </li>
<li>​        mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); </li>
<li>​      }//处理返回结果 </li>
<li>​    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); </li>
<li>​    } </li>
<li>} </li>
</ol>
<p>  相信这个方法大家都很熟了，我删除了一些与当前主体无关的代码，下面我们看getHandler是怎么做的：</p>
<p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>protected</strong> HandlerExecutionChain getHandler(HttpServletRequest request) <strong>throws</strong> Exception { </li>
<li>​    //这里有一个handlerMappings实例变量，如果你看过<a href="mvc:annotation-driven/">mvc:annotation-driven/</a>那篇文章，相信你就知道这 </li>
<li>​    //个handlerMappings都包括哪些HandlerMapping实例了？ </li>
<li>​    <strong>for</strong> (HandlerMapping hm : <strong>this</strong>.handlerMappings) { </li>
<li>​      HandlerExecutionChain handler = hm.getHandler(request); </li>
<li>​      <strong>if</strong> (handler != <strong>null</strong>) { </li>
<li>​        <strong>return</strong> handler; </li>
<li>​      } </li>
<li>​    } </li>
<li>​    <strong>return</strong> <strong>null</strong>; </li>
<li>} </li>
</ol>
<p>  <a href="http://blog.csdn.net/J080624/article/details/56276785" target="_blank" rel="noopener">这篇博客</a> 中说明了在启用该标签时Spring会默认注册RequestMappingHandlerMapping实例在处理@RequestMapping注解，而<a href="http://blog.csdn.net/j080624/article/details/56278461" target="_blank" rel="noopener">@RequestMapping (1)</a><a href="http://blog.csdn.net/j080624/article/details/56278461" target="_blank" rel="noopener"> </a>这篇博客说明了该HandlerMapping是如何处理@RequestMapping注解，以及怎么保存请求映射关系的。下面我们就看RequestMappingHandlerMapping的getHandler方法：</p>
<p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>//….. </li>
<li>//AbstractHandlerMapping </li>
<li>//….. </li>
<li><strong>public</strong> <strong>final</strong> HandlerExecutionChain getHandler(HttpServletRequest request) <strong>throws</strong> Exception { </li>
<li>​    Object handler = getHandlerInternal(request);//调用下面的方法 </li>
<li>​    <strong>if</strong> (handler == <strong>null</strong>) { </li>
<li>​      handler = getDefaultHandler(); </li>
<li>​    } </li>
<li>​    <strong>if</strong> (handler == <strong>null</strong>) { </li>
<li>​      <strong>return</strong> <strong>null</strong>; </li>
<li>​    } </li>
<li>​    // Bean name or resolved handler? </li>
<li>​    <strong>if</strong> (handler <strong>instanceof</strong> String) { </li>
<li>​      String handlerName = (String) handler; </li>
<li>​      handler = getApplicationContext().getBean(handlerName); </li>
<li>​    }//返回该请求对应的HandlerExecutionChain（包括处理器方法和拦截器） </li>
<li>​    <strong>return</strong> getHandlerExecutionChain(handler, request); </li>
<li>} </li>
<li>//….. </li>
<li>//AbstractHandlerMethodMapping(RequestMappingHandlerMapping 的祖先类) </li>
<li>//返回值是HandlerMethod </li>
<li>//….. </li>
<li>@Override </li>
<li><strong>protected</strong> HandlerMethod getHandlerInternal(HttpServletRequest request) <strong>throws</strong> Exception { </li>
<li>​    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request); </li>
<li>​    ///查找请求路径对应的HandlerMethod实例 </li>
<li>​    HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request); </li>
<li>​    //确保HandlerMethod中的handler是处理器实例而不是处理器名字 </li>
<li>​    <strong>return</strong> (handlerMethod != <strong>null</strong>) ? handlerMethod.createWithResolvedBean() : <strong>null</strong>; </li>
<li>} </li>
</ol>
<p>以上两个方法都是RequestMappingHandlerMapping的祖先类，逻辑很简单，先获取当前请求的路径，然后查找该路径对应的HandlerMethod实例。<a href="http://blog.csdn.net/j080624/article/details/56278461" target="_blank" rel="noopener">@RequestMapping (1)</a> 这篇博客最后讲到了，RequestMappingHandlerMapping中的两个映射表实例，urlMap和handlerMethods，第一个是路径与RequestMappingInfo的映射，第二个是RequestMappingInfo和HandlerMethod的映射，不用说，lookupHandlerMethod方法肯定是检索这两个变量了:</p>
<p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>protected</strong> HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request){ </li>
<li>​    List<Match> matches = <strong>new</strong> ArrayList<Match>(); </li>
<li>​    //查找urlMap，获取直接匹配的RequestMappingInfo列表。如 </li>
<li>​    //URL 是/work/produce/2， @RequestMapping（”/work/produce/2”)直接匹配 </li>
<li>​    List<T> directPathMatches = <strong>this</strong>.urlMap.get(lookupPath); </li>
<li>​    <strong>if</strong> (directPathMatches != <strong>null</strong>) { </li>
<li>​      addMatchingMappings(directPathMatches, matches, request); </li>
<li>​    } </li>
<li>​    <strong>if</strong> (matches.isEmpty()) {//如果没有找到直接匹配项，遍历所有的注册的RequestMappingInfo来查找 </li>
<li>​      //遍历所有可能的RequestMappingInfo，找到完全匹配的RequestMappingInfo实例，并生成Match对象 </li>
<li>​      //添加到Match列表中，Match是RequestMappingInfo和HandlerMethod的临时映射表。 </li>
<li>​      //举个例子：请求URL可能是GET:/work/produce/2, </li>
<li>​      //而@RequestMapping(“/work/produce/{no}” “GET”)此时需要匹配是否是GET请求，以及模式是否匹配 </li>
<li>​      addMatchingMappings(<strong>this</strong>.handlerMethods.keySet(), matches, request); </li>
<li>​    } </li>
<li>​    <strong>if</strong> (!matches.isEmpty()) {//排序，找出最佳匹配 </li>
<li>​      Comparator<Match> comparator = <strong>new</strong> MatchComparator(getMappingComparator(request)); </li>
<li>​      Collections.sort(matches, comparator); </li>
<li>​      Match bestMatch = matches.get(0); </li>
<li>​      <strong>if</strong> (matches.size() &gt; 1) {//如果可能的方法多余一个 </li>
<li>​        Match secondBestMatch = matches.get(1);//并且两个方法的@RequestMapping内容相同 </li>
<li>​        <strong>if</strong> (comparator.compare(bestMatch, secondBestMatch) == 0) {//抛出异常 </li>
<li>​          Method m1 = bestMatch.handlerMethod.getMethod(); </li>
<li>​          Method m2 = secondBestMatch.handlerMethod.getMethod(); </li>
<li>​          <strong>throw</strong> <strong>new</strong> IllegalStateException( </li>
<li>​              “Ambiguous handler methods mapped for HTTP path”); </li>
<li>​        } </li>
<li>​      } </li>
<li>​      //这里是处理请求路径中的变量，如果/work/produce/{no}匹配的/work/produce/2中将no=2 </li>
<li>​      //添加到Request的属性表中，以便后面@PathVarible参数的处理 </li>
<li>​      handleMatch(bestMatch.mapping, lookupPath, request); </li>
<li>​      <strong>return</strong> bestMatch.handlerMethod; </li>
<li>​    } </li>
<li>​    <strong>else</strong> { </li>
<li>​      <strong>return</strong> handleNoMatch(handlerMethods.keySet(), lookupPath, request); </li>
<li>​    } </li>
<li>} </li>
</ol>
<p>  在进行URL匹配中，Spring会先查找是否存在直接匹配的RequestMappingInfo实例，即@RequestMapping中的value，method属性完全匹配请求的，如果没有找到通常是存在PathVariable的，如果上面讲的/{no}和/222的情况等也是匹配的, 找到匹配项后，需要找出最优解，然后将路径中的变量存入Request的变量表中，我们分别详细的了解下：</p>
<p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>private</strong> <strong>void</strong> addMatchingMappings(Collection<T> mappings, List<Match> matches,  </li>
<li>​                                HttpServletRequest request) { </li>
<li>​    <strong>for</strong> (T mapping : mappings) {//遍历所有的RequestMappingInfo列表 </li>
<li>​      T match = getMatchingMapping(mapping, request);//获取匹配的RequestMappingInfo实例 </li>
<li>​      <strong>if</strong> (match != <strong>null</strong>) {//并生成匹配的RequestMappingInfo实例和对应HandlerMethod的Match实例 </li>
<li>​        matches.add(<strong>new</strong> Match(match, handlerMethods.get(mapping))); </li>
<li>​      } </li>
<li>​    } </li>
<li>} </li>
</ol>
<p>  继续看getMatchingMapping的实现：</p>
<p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> RequestMappingInfo getMatchingCondition(HttpServletRequest request) { </li>
<li>​    //查看RequestMappingInfo的所有属性是否匹配 </li>
<li>​    RequestMethodsRequestCondition methods = methodsCondition.getMatchingCondition(request); </li>
<li>​    ParamsRequestCondition params = paramsCondition.getMatchingCondition(request); </li>
<li>​    HeadersRequestCondition headers = headersCondition.getMatchingCondition(request); </li>
<li>​    ConsumesRequestCondition consumes = consumesCondition.getMatchingCondition(request); </li>
<li>​    ProducesRequestCondition produces = producesCondition.getMatchingCondition(request); </li>
<li>​    <strong>if</strong> (methods == <strong>null</strong> || params == <strong>null</strong> || headers == <strong>null</strong>  </li>
<li>​                          || consumes == <strong>null</strong> || produces == <strong>null</strong>) { </li>
<li>​      <strong>return</strong> <strong>null</strong>; </li>
<li>​    }//我们重点看这个，路径是否匹配 </li>
<li>​    PatternsRequestCondition patterns = patternsCondition.getMatchingCondition(request); </li>
<li>​    <strong>if</strong> (patterns == <strong>null</strong>) { </li>
<li>​      <strong>return</strong> <strong>null</strong>; </li>
<li>​    } </li>
<li>​    RequestConditionHolder custom = customConditionHolder.getMatchingCondition(request); </li>
<li>​    <strong>if</strong> (custom == <strong>null</strong>) { </li>
<li>​      <strong>return</strong> <strong>null</strong>; </li>
<li>​    } </li>
<li>​    <strong>return</strong> <strong>new</strong> RequestMappingInfo(patterns, methods, params, headers,  </li>
<li>​                            produces, custom.getCondition()); </li>
<li>} </li>
</ol>
<p>  我们知道RequestMappingInfo就是@RequestMapping注解的抽象，它包含@RequestMapping中的所有属性，因此在查找匹配项时，需要查看所有这些属性是否与请求匹配。我们这里只看路径模式是否匹配，其他属性自行研究，都很简单：</p>
<p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> PatternsRequestCondition getMatchingCondition(HttpServletRequest request) { </li>
<li>​    <strong>if</strong> (<strong>this</strong>.patterns.isEmpty()) { </li>
<li>​      <strong>return</strong> <strong>this</strong>; </li>
<li>​    }//获取请求路径如/work/produce/2 </li>
<li>​    String lookupPath = <strong>this</strong>.urlPathHelper.getLookupPathForRequest(request); </li>
<li>​    List<String> matches = <strong>new</strong> ArrayList<String>(); </li>
<li>​    //遍历@RequestMapping中的所有模式 </li>
<li>​    <strong>for</strong> (String pattern : patterns) { </li>
<li>​      //找出与请求路径匹配的模式，如/work/produce/{no} </li>
<li>​      String match = getMatchingPattern(pattern, lookupPath); </li>
<li>​      <strong>if</strong> (match != <strong>null</strong>) { </li>
<li>​        matches.add(match); </li>
<li>​      } </li>
<li>​    }//排序 </li>
<li>​    Collections.sort(matches, <strong>this</strong>.pathMatcher.getPatternComparator(lookupPath)); </li>
<li>​    //返回匹配的请求模式实例 </li>
<li>​    <strong>return</strong> matches.isEmpty() ? <strong>null</strong> :  </li>
<li>​      <strong>new</strong> PatternsRequestCondition(matches, <strong>this</strong>.urlPathHelper, <strong>this</strong>.pathMatcher,  </li>
<li>​                    <strong>this</strong>.useSuffixPatternMatch, <strong>this</strong>.useTrailingSlashMatch); </li>
<li>} </li>
<li></li>
<li><strong>private</strong> String getMatchingPattern(String pattern, String lookupPath) { </li>
<li>​    <strong>if</strong> (pattern.equals(lookupPath)) { </li>
<li>​      <strong>return</strong> pattern;//直接匹配 </li>
<li>​    } </li>
<li>​    <strong>if</strong> (<strong>this</strong>.useSuffixPatternMatch) {//是否使用后缀模式，/abc/de匹配/abc </li>
<li>​      <strong>boolean</strong> hasSuffix = pattern.indexOf(‘.’) != -1; </li>
<li>​      <strong>if</strong> (!hasSuffix &amp;&amp; <strong>this</strong>.pathMatcher.match(pattern + “.*”, lookupPath)) { </li>
<li>​        <strong>return</strong> pattern + “.*”; </li>
<li>​      } </li>
<li>​    }//匹配/work/produce/{no} 和/work/produce/2 </li>
<li>​    <strong>if</strong> (<strong>this</strong>.pathMatcher.match(pattern, lookupPath)) { </li>
<li>​      <strong>return</strong> pattern; </li>
<li>​    }//是否使用结尾的斜线匹配 </li>
<li>​    <strong>boolean</strong> endsWithSlash = pattern.endsWith(“/“); </li>
<li>​    <strong>if</strong> (<strong>this</strong>.useTrailingSlashMatch) { </li>
<li>​      <strong>if</strong> (!endsWithSlash &amp;&amp; <strong>this</strong>.pathMatcher.match(pattern + “/“, lookupPath)) { </li>
<li>​        <strong>return</strong> pattern +”/“; </li>
<li>​      } </li>
<li>​    } </li>
<li>​    <strong>return</strong> <strong>null</strong>; </li>
<li>} </li>
</ol>
<p>  至于上面的pathMatcher.match方法这里就不分析了，可以自己看看，匹配算法还是比较复杂的，主要是尽可能的全面，除了进行匹配外，还会将路径中的变量保存起来以便@PathVariable参数使用。</p>
<p>  以上便是整个的匹配过好麻烦，或许你会说这会不会降低Spring的性能？实话说，在处理首次请求时，效率是很差，但是Spring使用了各种缓存策略，一旦程序进入正轨，效率就非常高了。</p>
<h3 id="三、处理器方法的调用"><a href="#三、处理器方法的调用" class="headerlink" title="三、处理器方法的调用"></a>三、处理器方法的调用</h3><p>  现在我们已经查找到了对应请求的处理器方法，下面我们就看Spring是如何在运行时动态地调用处理器方法的，并传递正确的参数。在doDispatch方法中，我们看到，确定了处理器（方法）后，Spring接着获取了该处理器方法的适配器（HandlerAdapter概念讲解中说到过，用来调用处理器方法的）</p>
<p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>protected</strong> HandlerAdapter getHandlerAdapter(Object handler) <strong>throws</strong> ServletException { </li>
<li>​    //这个handlerAdapters跟handlerMappings一样，启用<a href="mvc:annoation-driven/">mvc:annoation-driven/</a>后默认注册 </li>
<li>​    //RequestMappingHandlerAdapter（since3.1） </li>
<li>​    <strong>for</strong> (HandlerAdapter ha : <strong>this</strong>.handlerAdapters) { </li>
<li>​      <strong>if</strong> (ha.supports(handler)) { </li>
<li>​        <strong>return</strong> ha; </li>
<li>​      } </li>
<li>​    } </li>
<li>​    <strong>throw</strong> <strong>new</strong> ServletException(“No adapter for handler [“ + handler + </li>
<li>​        “]: Does your handler implement a supported interface like Controller?”); </li>
<li>} </li>
<li>//是否支持当前处理器，其实就是看看处理器是不是HandlerMethod实例 </li>
<li><strong>public</strong> <strong>final</strong> <strong>boolean</strong> supports(Object handler) { </li>
<li>​    <strong>return</strong> handler <strong>instanceof</strong> HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler); </li>
<li>} </li>
</ol>
<p>  获取了HandlerAdapter后，Spring就会调用handlerAdapter实例的handle方法，并返回ModelAndView实例：</p>
<p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li>@Override </li>
<li><strong>protected</strong> <strong>final</strong> ModelAndView handleInternal(HttpServletRequest request, </li>
<li>​      HttpServletResponse response, HandlerMethod handlerMethod) <strong>throws</strong> Exception { </li>
<li>​    //如果HandlerMethod所属的处理器被@SessionAttribute注解标记了 </li>
<li>​    <strong>if</strong> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) { </li>
<li>​     //设置响应头信息，防止缓存以便Session属性的管理 </li>
<li>​     checkAndPrepare(request, response, <strong>this</strong>.cacheSecondsForSessionAttributeHandlers, <strong>true</strong>); </li>
<li>​    } </li>
<li>​    <strong>else</strong> { </li>
<li>​      //设置响应头，缓存默认时间 </li>
<li>​      checkAndPrepare(request, response, <strong>true</strong>); </li>
<li>​    } </li>
<li>​    //要求在Session级别上进行同步，即同一个客户端的多个请求需要阻塞调用该处理器方法 </li>
<li>​    <strong>if</strong> (<strong>this</strong>.synchronizeOnSession) { </li>
<li>​      HttpSession session = request.getSession(<strong>false</strong>); </li>
<li>​      <strong>if</strong> (session != <strong>null</strong>) { </li>
<li>​        Object mutex = WebUtils.getSessionMutex(session); </li>
<li>​        <strong>synchronized</strong> (mutex) {//调用 </li>
<li>​          <strong>return</strong> invokeHandleMethod(request, response, handlerMethod); </li>
<li>​        } </li>
<li>​      } </li>
<li>​    }//调用 </li>
<li>​    <strong>return</strong> invokeHandleMethod(request, response, handlerMethod); </li>
<li>} </li>
</ol>
<p>  我们接着看invokeHandlerMethod方法：</p>
<p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>private</strong> ModelAndView invokeHandleMethod(HttpServletRequest request, </li>
<li>​      HttpServletResponse response, HandlerMethod handlerMethod) <strong>throws</strong> Exception { </li>
<li>​    //包装请求和响应对象 </li>
<li>​    ServletWebRequest webRequest = <strong>new</strong> ServletWebRequest(request, response); </li>
<li>​    //获取与HandlerMethod对应的DataBinderFactory。 </li>
<li>​    WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); </li>
<li>​    //获取处理器方法所属处理器中被@ModelAttribute标记，但是没有被@RequestMapping标记的方法 </li>
<li>​    ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); </li>
<li>​    //创建请求映射方法，并将HandlerAdapter中的参数解析器列表和返回值处理器列表传递给它。 </li>
<li>​    ServletInvocableHandlerMethod requestMappingMethod =  </li>
<li>​                   createRequestMappingMethod(handlerMethod, binderFactory); </li>
<li>​    //创建ModelAndViewContainer </li>
<li>​    ModelAndViewContainer mavContainer = <strong>new</strong> ModelAndViewContainer(); </li>
<li>​    mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request)); </li>
<li>​    modelFactory.initModel(webRequest, mavContainer, requestMappingMethod); </li>
<li>​    mavContainer.setIgnoreDefaultModelOnRedirect(<strong>this</strong>.ignoreDefaultModelOnRedirect); </li>
<li>​    //获取并设置当前请求的异步调用链实例 </li>
<li>​    AsyncExecutionChain chain = AsyncExecutionChain.getForCurrentRequest(request); </li>
<li>​    chain.addDelegatingCallable(getAsyncCallable(mavContainer, modelFactory, webRequest)); </li>
<li>​    chain.setAsyncWebRequest(createAsyncWebRequest(request, response)); </li>
<li>​    chain.setTaskExecutor(<strong>this</strong>.taskExecutor); </li>
<li>​    //调用该处理器方法。 </li>
<li>​    requestMappingMethod.invokeAndHandle(webRequest, mavContainer); </li>
<li></li>
<li>​    <strong>if</strong> (chain.isAsyncStarted()) { </li>
<li>​      <strong>return</strong> <strong>null</strong>; </li>
<li>​    } </li>
<li>​    //获取并返回ModelAndView </li>
<li>​    <strong>return</strong> getModelAndView(mavContainer, modelFactory, webRequest); </li>
<li>} </li>
</ol>
<p>  关于异步调用链那块我们暂不关心，后续文章会专题讨论。从上面代码可以看到，在调用方法前，分别检查了处理器中存在的@InitBinder注解的方法和@ModelAttribute注解的方法，InitBinder方法用于类型转化，如将String转化为Date类型等，可以通过@InitBinder方法实现，感兴趣可以自己看看，不在详细分析。至于@ModelAttribute注解的方法，其返回值会被放入Model对象中供视图使用。下面我们看invokeAndHandle方法：</p>
<p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>final</strong> <strong>void</strong> invokeAndHandle(ServletWebRequest webRequest, </li>
<li>​      ModelAndViewContainer mavContainer, Object… providedArgs) <strong>throws</strong> Exception { </li>
<li>​    //….省略异步调用方法，暂不考虑 </li>
<li>​    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); </li>
<li>​    //….省略几行代码，暂不考虑 </li>
<li>​    <strong>try</strong> {//处理返回结果 </li>
<li>​      <strong>this</strong>.returnValueHandlers.handleReturnValue(returnValue,  </li>
<li>​                  getReturnValueType(returnValue), mavContainer, webRequest); </li>
<li>​    } </li>
<li>} </li>
</ol>
<p>  接着我们看下invokeForRequest方法：—-we are so close.</p>
<p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>public</strong> <strong>final</strong> Object invokeForRequest(NativeWebRequest request, </li>
<li>​                     ModelAndViewContainer mavContainer, </li>
<li>​                     Object… providedArgs) <strong>throws</strong> Exception { </li>
<li>​    //获取方法参数值。 </li>
<li>​    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); </li>
<li>​    //传递参数值，调用，返回返回值 </li>
<li>​    Object returnValue = invoke(args); </li>
<li>​    <strong>return</strong> returnValue; </li>
<li>} </li>
</ol>
<p>  啊哈上面的代码貌似很简单，实则不是，重点就在getMethodArgumentValues方法，这才是我们这片文章的真正主题呢。打起精神来了：</p>
<p><strong>[java]</strong><a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">view plain</a> <a href="http://blog.csdn.net/J080624/article/details/56278869#" target="_blank" rel="noopener">copy</a></p>
<ol>
<li><strong>private</strong> Object[] getMethodArgumentValues( </li>
<li>​      NativeWebRequest request, ModelAndViewContainer mavContainer, </li>
<li>​      Object… providedArgs) <strong>throws</strong> Exception { </li>
<li>​    //获取处理器方法的MethodParameter数组，就是方法的“参数定义”列表。 </li>
<li>​    MethodParameter[] parameters = getMethodParameters(); </li>
<li>​    Object[] args = <strong>new</strong> Object[parameters.length]; </li>
<li>​    //遍历所有方法参数 </li>
<li>​    <strong>for</strong> (<strong>int</strong> i = 0; i &lt; parameters.length; i++) { </li>
<li>​      MethodParameter parameter = parameters[i]; </li>
<li>​      parameter.initParameterNameDiscovery(parameterNameDiscoverer); </li>
<li>​      //确定泛型参数的类型 </li>
<li>​      GenericTypeResolver.resolveParameterType(parameter, getBean().getClass()); </li>
<li>​      //根据提供的参数值，解析当前参数的值 </li>
<li>​      args[i] = resolveProvidedArgument(parameter, providedArgs); </li>
<li>​      <strong>if</strong> (args[i] != <strong>null</strong>) { </li>
<li>​        <strong>continue</strong>; </li>
<li>​      } </li>
<li>​      //根据内置的参数解析器（上面的图片中列出了），来解析当前的参数值 </li>
<li>​      <strong>if</strong> (argumentResolvers.supportsParameter(parameter)) { </li>
<li>​        <strong>try</strong> { </li>
<li>​          args[i] = argumentResolvers.resolveArgument(parameter, mavContainer, </li>
<li>​                                 request, dataBinderFactory); </li>
<li>​          <strong>continue</strong>; </li>
<li>​        } </li>
<li>​      } </li>
<li>​      //如果参数值依旧为空，抛出异常。 </li>
<li>​      <strong>if</strong> (args[i] == <strong>null</strong>) { </li>
<li>​     String msg = getArgumentResolutionErrorMessage(“No suitable resolver for argument”, i); </li>
<li>​     <strong>throw</strong> <strong>new</strong> IllegalStateException(msg); </li>
<li>​      } </li>
<li>​    } </li>
<li>​    <strong>return</strong> args; </li>
<li>} </li>
</ol>
<p>  该方法是HandlerMethod中的方法，因此可以调用getMethodParameters()方法获取参数列表，然后遍历这些参数，分别用参数解析器来解析当前参数值，其中，argumentResolvers是HandlerMethodArgumentResolverComposite，概念讲解中已经阐述，它包含了所有的参数解析器的列表，以及参数类型和解析器的映射表，我们不妨看看到底什么怎么回事：</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">王志强</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/04/19/DispatcherServlet%E8%A7%A3%E8%AF%BB/">http://yoursite.com/2020/04/19/DispatcherServlet%E8%A7%A3%E8%AF%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DispatcherServlet/">DispatcherServlet</a></div><div class="post_share"><div class="social-share" data-image="{&quot;index_enable&quot;:true,&quot;aside_enable&quot;:true,&quot;archives_enable&quot;:true,&quot;position&quot;:&quot;both&quot;,&quot;default_cover&quot;:&quot;/img/index.jpg&quot;}" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/19/JavaScript/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">JavaScript入门</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/19/hello-world/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Hello World</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 王志强</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":-20},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body></html>